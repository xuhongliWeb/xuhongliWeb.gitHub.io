{"meta":{"title":"x","subtitle":null,"description":null,"author":"xu","url":"https://xuhongliweb.github.io","root":"/"},"pages":[{"title":"","date":"2020-12-21T14:11:33.517Z","updated":"2020-12-21T14:04:02.010Z","comments":true,"path":"404.html","permalink":"https://xuhongliweb.github.io/404.html","excerpt":"","text":"var QZONE = window.QZONE || {}; function imagezoom(imgobj, box_w, box_h) { var src_w = imgobj.width; var src_h = imgobj.height; var r1 = src_w / src_h, r2 = box_w / box_h; var dst_w, dst_h; if (r1 > r2) { dst_w = box_w; dst_h = Math.round(dst_w / src_w * src_h); } else { if (r1 < r2) { dst_h = box_h; dst_w = Math.round(dst_h / src_h * src_w); } else { dst_w = box_w; dst_h = box_h; } } imgobj.style.marginLeft = (box_w - dst_w) / 2 + \"px\"; imgobj.style.marginTop = (box_h - dst_h) / 2 + \"px\"; imgobj.style.width = dst_w + \"px\"; imgobj.style.height = dst_h + \"px\"; imgobj.style.opacity = 1; } (function(_w, _d) { var ha = _d.head || _d.getElementsByTagName(\"head\")[0]; var $scope = {}; var current; var tmnow; var chId; var homePageUrl, homePageName; var scs = document.getElementsByTagName(\"script\"); if (location.href.indexOf(\"fm.qq.com\") > -1 || location.href.indexOf(\"fm.qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u4f01\\u9e45FM\"; homePageUrl = \"http://fm.qq.com\"; } else { if (location.href.indexOf(\"qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u6211\\u7684\\u7a7a\\u95f4\"; homePageUrl = \"http://qzone.qq.com\"; } else { homePageName = \"\\u8fd4\\u56de\\u817e\\u8baf\\u7f51\"; homePageUrl = \"http://www.qq.com\"; } } for (var i = 0;i < scs.length;i++) { if (scs[i].src.indexOf(\"404/search_children.js\") > -1) { if (scs[i].getAttribute(\"homePageUrl\")) { homePageUrl = scs[i].getAttribute(\"homePageUrl\"); } if (scs[i].getAttribute(\"homePageName\")) { homePageName = scs[i].getAttribute(\"homePageName\"); } break; } } $scope.rettext = homePageName; $scope.retlink = homePageUrl; function getData(srcUrl, callback) { var sc = _d.createElement(\"script\"); function orc() { if (sc.readyState === \"loaded\") { setTimeout(function() { callback && callback(); }, 0); } } if (sc.addEventListener) { if (callback) { sc.addEventListener(\"load\", callback, false); } } else { sc.attachEvent(\"onreadystatechange\", orc); } ha && ha.appendChild(sc); sc.src = srcUrl; } function resolveData(d) { var tid, len, ddata = [], tdata; if (\"object\" == typeof d && (d.data && (len = d.data.length))) { for (var i = 0;i < len;i++) { var expire = d.data[i].expire; d.data[i]._id = new Date * Math.random() * Math.random() * 1E7; if (expire && tmnow * 1E3 < Date.parse(expire.replace(/\\s[\\s\\S]*$/, \"\").replace(/\\-/g, \"/\"))) { var _c = d.data[i].city, _p = d.data[i].province; if (_c && city) { if ((\"_\" + _c + \"_\").indexOf(\"_\" + city + \"_\") > -1) { ddata.push(d.data[i]); continue; } } if (_p && province) { if ((\"_\" + _p + \"_\").indexOf(\"_\" + province + \"_\") > -1) { ddata.push(d.data[i]); } } } } tid = Math.floor(Math.random() * (ddata.length || len)); tdata = (ddata.length ? ddata : d.data)[chId = tid]; if (_w.foundjsondata) { tdata.ta = tdata.sex.indexOf(\"\\u5973\") > -1 ? \"\\u5979\" : \"\\u4ed6\"; tdata.name = \"\\u201c7\\u00b718\\u7279\\u5927\\u62d0\\u5356\\u5a74\\u513f\\u6848\\u201d\\u544a\\u7834\\uff0c\\u88ab\\u89e3\\u6551\\u768415\\u540d\\u5b69\\u5b50\\u4e2d\\uff0c2\\u4eba\\u7531\\u4eb2\\u751f\\u7236\\u6bcd\\u9886\\u56de\\uff0c\\u4ecd\\u670913\\u540d\\u5b69\\u5b50\\u672a\\u627e\\u5230\\u4eb2\\u751f\\u7236\\u6bcd\\uff0c\\u88ab\\u5b89\\u7f6e\\u5728\\u60e0\\u5dde\\u5e02\\u793e\\u4f1a\\u798f\\u5229\\u9662\\uff0c\" + tdata.ta + \"\\u662f\\u5176\\u4e2d\\u4e4b\\u4e00\\u3002\"; tdata.url = tdata.url.replace(/#p=(\\d{1,2})/, function(a, n) { return \"#p=\" + (+n + 1); }); return format(tmpl2, tdata); } if (!tdata.ext1) { tdata.ext1 = \"\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5bfb\\u627e\\u5931\\u8e2a\\u5b9d\\u8d1d\"; } return tdata; } } function setTopData(tdata) { current = tdata; $scope.topname = tdata.name; $scope.topgender = tdata.sex; $scope.topbirth = tdata.birth_time; $scope.toplostdate = tdata.lost_time; $scope.toplostplace = tdata.lost_place; $scope.toplostdesc = tdata.child_feature; $scope.toplink = tdata.url; $scope.topimg = tdata.child_pic; $scope.topid = tdata._id; document.body.innerHTML = template(\"body\", $scope); } function init(data) { tmnow = data.tm_now * 1E3; var tdata = resolveData(jsondata); $scope.whichin = 0; jsondata.data.splice(chId, 1); $scope.otherdata = [tdata].concat(jsondata.data.slice(0, 5)); setTopData(tdata); } var timeout; window._Callback = function(d) { clearTimeout(timeout); init(d); }; timeout = setTimeout(function() { _Callback({tm_now:(new Date).getTime() / 1E3}); }, 2E3); _w.share = function(target) { var summary = [\"\\u80cc\\u666f\\uff1a\", current.name, \"\\uff0c\\u6027\\u522b\\uff1a\", current.sex, \"\\uff0c\\u51fa\\u751f\\u65f6\\u95f4\\uff1a\", current.birth_time, \"\\uff0c\\u5931\\u8e2a\\u65f6\\u95f4\\uff1a\", current.lost_time, \"\\uff0c\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a\", current.child_feature].join(\"\"); if (summary) { summary = \"#\\u5bfb\\u627e\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d#\" + summary; } var stitle = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8be6\\u60c5\"; var desc = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\"; var encode = encodeURIComponent; var opts = {\"surl\":\"http://qzone.qq.com/gy/404/\" + current.id + \"/lostchild.html\", \"site\":\"QQ\\u7a7a\\u95f4\", \"summary\":summary || \"#\\u5b9d\\u8d1d\\u56de\\u5bb6#\\u817e\\u8baf\\u5fd7\\u613f\\u8005\\u7528\\u6280\\u672f\\u70b9\\u4eae\\u516c\\u76ca\\uff0c\\u8ba9\\u6211\\u4eec\\u4e00\\u8d77\\u5bfb\\u627e\\u8d70\\u5931\\u7684\\u513f\\u7ae5\\u5427\\uff01\", \"stitle\":stitle, \"pics\":current.child_pic, \"desc\":desc, \"origin_url\":current.url}; var surl = opts.surl || \"http://www.qq.com/404/\", summary = opts.summary || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u5185\\u5bb9\", stitle = opts.stitle || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u6807\\u9898\", pics = opts.pics || \"http://qzonestyle.gtimg.cn/qzone_v6/act/img/20120422_qzone_7_years/pop_up/icon-pop-seven-years.png\", site = opts.site || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u94fe\\u63a5\\u7684\\u6587\\u5b57\", desc = opts.desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", origin_url = opts.origin_url || \"http://www.qq.com/404/\"; var shareList = {weibo:{method:function(evt) { var w = \"http://v.t.qq.com/share/share.php\", q = [\"?site=\", encode(surl + \"#via=share_t_weib\"), \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"weibo\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, qzone:{method:function(evt) { var buff = [], ps = {url:surl + \"#via=404-qzoneshare\", desc:desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", summary:summary, title:stitle, pics:pics, site:site}; for (var k in ps) { buff.push(k + \"=\" + encode(ps[k] || \"\")); } var w = \"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?\" + buff.join(\"&\"), q = [\"#via=share_t_qzone\", \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"qzone\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, sina:{method:function() { var w = \"http://v.t.sina.com.cn/share/share.php\", q = [\"?url=\", encode(surl + \"#via=share_x_weib\"), \"&title=\", encode(summary), \"&source=\", \"&sourceUrl=\", surl, \"&content=utf-8\", \"&pic=\", encode(pics)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"sina\", \"toolbar=0,status=0,resizable=1,width=440,height=430\"); }}, kaixin:{method:function() { var n = \"http://www.kaixin001.com/repaste/bshare.php?rurl=\" + encode(surl + \"#via=share_kaixin\") + \"&rcontent=&rtitle=\" + encode(summary); openit(n, \"kaixin\", \"toolbar=0,status=0,resizable=1,width=600,height=360\"); }}, renren:{method:function() { var n = \"http://www.connect.renren.com/share/sharer?title=\" + encode(summary) + \"&url=\" + encode(surl + \"#via=share_renren\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=510,height=300\"); if (p) { p.focus(); } }}, weixin:{method:function() { var n = \"http://qzone.qq.com/gy/404/page/qrcode.html?url=\" + encode(origin_url + \"#via=share_weixin\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=620,height=430\"); if (p) { p.focus(); } }}}; var openit = function(u, n, p) { function o() { var z; if (!(z = window.open(u, n, p))) { location.href = u; } else { z.focus(); } } o(); }; shareList[target] && shareList[target].method(); }; _w.toThis = function(id) { for (var i = 0;i < $scope.otherdata.length;i++) { if ($scope.otherdata[i]._id == id) { setTopData($scope.otherdata[i]); break; } } return false; }; var meta = document.createElement(\"meta\"); meta.name = \"viewport\"; meta.content = \"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"; ha.appendChild(meta); (function registerStyle() { var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = \"https://qzone.qq.com/gy/404/style/404style.css\"; ha.appendChild(link); })(); (function initStat() { var qqDomainNameRE = /\\.qq\\.com$/i, qzoneDomainNameRE = /\\bqzone\\.qq\\.com$/i, qzsDomainNameRE = /\\bqzonestyle\\.gtimg\\.cn$/i; function cb() { var url = location.host; var src = \"\"; if (qzoneDomainNameRE.test(url)) { src = \"new404.qzone\"; } else { if (qqDomainNameRE.test(url)) { src = \"new404.qq\"; } else { if (qzsDomainNameRE.test(url)) { src = \"new404.qzonestyle\"; } else { src = url.replace(\".\", \"_\"); } } } _w.TCISD && (_w.TCISD.pv && _w.TCISD.pv(\"hat.qzone.qq.com\", \"/gy/lostchild/\" + src)); } getData(\"https://qzonestyle.gtimg.cn/ac/qzfl/stat.js\", cb); })(); })(window, document); !function() { function a(a, b) { return(/string|function/.test(typeof b) ? h : g)(a, b); } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a; } function c(a) { return l[a]; } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c); } function e(a, b) { if (m(a)) { for (var c = 0, d = a.length;d > c;c++) { b.call(a, a[c], c, a); } } else { for (c in a) { b.call(a, a[c], c); } } } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\");e.match(c);) { e = e.replace(c, \"/\"); } return e; } function g(b, c) { var d = a.get(b) || i({filename:b, name:\"Render Error\", message:\"Template not found\"}); return c ? d(c) : d; } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function() { return new k(c); }; } var d = j[a] = function(c) { try { return new b(c, a) + \"\"; } catch (d) { return i(d)(); } }; return d.prototype = b.prototype = n, d.toString = function() { return b + \"\"; }, d; } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) { c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); } else { for (var d in a) { c += \"\\n\" + a[d] + \"\\n\\n\"; } } return function() { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b; }; } var j = a.cache = {}, k = this.String, l = {\"\":\"&#62;\", '\"':\"&#34;\", \"'\":\"&#39;\", \"&\":\"&#38;\"}, m = Array.isArray || function(a) { return \"[object Array]\" === {}.toString.call(a); }, n = a.utils = {$helpers:{}, $include:function(a, b, c) { return a = f(c, a), g(a, b); }, $string:b, $escape:d, $each:e}, o = a.helpers = n.$helpers; a.get = function(a) { return j[a.replace(/^\\.\\//, \"\")]; }, a.helper = function(a, b) { o[a] = b; }, \"function\" == typeof define ? define(function() { return a; }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function(a) { var b = this, c = (b.$helpers, b.$escape), d = a.retlink, e = a.rettext, f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404\\uff0c\\u60a8\\u8bbf\\u95ee\\u7684\\u9875\\u9762\\u627e\\u4e0d\\u56de\\u6765\\u4e86\\uff0c\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5e2e\\u4ed6\\u4eec\\u56de\\u5bb6\\uff01 ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') \\u51fa\\u751f\\u65e5\\u671f\\uff1a', r += c(j), r += ' \\u5931\\u8e2a\\u65f6\\u95f4\\uff1a', r += c(l), r += ' \\u5931\\u8e2a\\u5730\\u70b9\\uff1a', r += c(m), r += ' \\u5931\\u8e2a\\u4eba\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a', r += c(n), r += ' \\u67e5\\u770b\\u8be6\\u60c5 \\u5206\\u4eab \\u817e\\u8baf\\u5fae\\u535a QQ\\u7a7a\\u95f4 \\u65b0\\u6d6a\\u5fae\\u535a \\u5fae\\u4fe1 ', p(q, function(a) { r += ' '; }), r += \" \", new k(r); }); }();"},{"title":"leetCode","date":"2019-09-22T05:36:04.000Z","updated":"2020-12-21T14:04:02.013Z","comments":true,"path":"tags/index-1.html","permalink":"https://xuhongliweb.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-09-20T09:12:18.000Z","updated":"2020-12-21T14:04:02.013Z","comments":true,"path":"categories/index.html","permalink":"https://xuhongliweb.github.io/categories/index.html","excerpt":"","text":""},{"title":"vue","date":"2019-10-16T06:48:57.000Z","updated":"2020-12-21T14:04:02.013Z","comments":true,"path":"tags/index-2.html","permalink":"https://xuhongliweb.github.io/tags/index-2.html","excerpt":"","text":""},{"title":"hexo","date":"2019-09-20T09:28:44.000Z","updated":"2020-12-21T14:04:02.014Z","comments":true,"path":"tags/index.html","permalink":"https://xuhongliweb.github.io/tags/index.html","excerpt":"","text":""},{"title":"js","date":"2019-10-16T11:42:24.000Z","updated":"2020-12-21T14:04:02.014Z","comments":true,"path":"tags/index-3.html","permalink":"https://xuhongliweb.github.io/tags/index-3.html","excerpt":"","text":""}],"posts":[{"title":"Promise","slug":"Promise","date":"2020-12-20T02:25:09.000Z","updated":"2020-12-21T14:04:02.011Z","comments":true,"path":"2020/12/20/Promise/","link":"","permalink":"https://xuhongliweb.github.io/2020/12/20/Promise/","excerpt":"","text":"Promise 是什么？Promise 是异步编程的一种解决方案，比传统的方案一一回调更合理更强大。 所谓Promise ,简单来说。里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果从语法上说 。 Promise 是一个对象， 从它可以获取异步操作的消息。Promise提供的API，各种异步操作都可以用通用的方法处理 。 Promise 对象有两个特点 对象的状态不受外界影响Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 一旦状态改变。就不会在变 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本语法 promise.prototype.then() Promise.prototype.catch()promise.prototype.then(res,catch) 的第二个参数也能捕捉到错误，一般不推荐 Promise.prototype.finally()finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected Promise.all()Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。只有所有all里面包含的promise状态为fulfilled 整体才会返回fulfilled, 同样一个错误整体就返回rejected了 promise.race()Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上述代码 p1,p2,p3 只要有一个实列率先改变， p的状态就跟着改变。 那个率先改变的promise返回值就传递给离p的回调函数 const p = Promise.race([p1, p2, p3]);Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。 Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 123Promise.resolve(&apos;foo&apos;)// 等价于new Promise(resolve =&gt; resolve(&apos;foo&apos;)) Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 手写基本Promise这一版本 支持 异步任务 then catch简版 Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * @description * executor - 传进来的一堆 用户写的方法 * promise 对象初始状态为peading, 在被resolve或 reject 是 状态改为 Fulfilled 或 Rejected * resolve 接收成功的数据， reject 接收失败或错误的数据 * Promise对象必须有一个then方法， 且只接收两个可函数参数 onFulfilled / onRejected * 发布订阅模式支持异步 * catch方法其实就是没有成功回调的then方法，这个很好理解，因为一旦失败之后就会调用reject,最终都会走到then方法的失败回调中，只是简单的把then方法换个名字而已。 */ const pConfig = &#123; PEADINGD : &apos;PEADINGD&apos;, RESOLVED: &apos;RESOLVED&apos;, REJECTED: &apos;RESOLVED&apos; &#125; export class vxPromise &#123; constructor(executor) &#123; console.log(executor, &apos;执行者 executor -1 &apos;) this.status = pConfig.PEADINGD // 默认等待状态 this.value = undefined // 这个应该是 成功的结果把？ this.reason = undefined // 失败的结果？ this.onResolvedCallbacks = [] // 存放 成功函数的 this.onRejectedCallbacks = [] // 存放失败函数的 let resolve = (value) =&gt; &#123; console.log(value, &apos;resolve-value -4&apos;) if(this.status === pConfig.PEADINGD) &#123; // 等待状态才执行 this.value = value this.status = pConfig.RESOLVED // 依次执行异步任务 由 then 的时候push 进去 this.onResolvedCallbacks.forEach(fn =&gt; &#123; console.log(fn,&apos;回调里的&apos;, &apos;成功&apos;) // fn() &#125;) &#125; &#125; let reject = (value) =&gt; &#123; console.log(value, &apos;reject-value-4&apos;) if(this.status === pConfig.PEADINGD) &#123; this.reason = value // 更新状态 this.status = pConfig.REJECTED // 依次执行异步任务 由 then 的时候push 进去 this.onRejectedCallbacks.forEach(fn =&gt; &#123; console.log(fn,&apos;回调里的&apos;, &apos;失败&apos;) // fn() &#125;) &#125; &#125; // 执行 executor 传入我们定义的成功和失败的函数； 把用户写的resolve,reject的结果 传入 内部 resolve 和 reject try &#123; executor(resolve,reject) &#125;catch (e) &#123; console.log(&apos;catch错误&apos;, e); reject(e); //如果内部出错 直接将error手动调用reject向下传递 &#125; &#125; then(onfufilled,onrejected) &#123; console.log( this.onResolvedCallbacks, &apos;onrejected-2&apos;) if(this.status === pConfig.RESOLVED) &#123; onfufilled(this.value) &#125; if(this.status === pConfig.REJECTED) &#123; onrejected(this.reason) &#125; // 执行异步任务 if(this.status === pConfig.PEADINGD) &#123; console.log(&apos;push-3&apos;) this.onResolvedCallbacks.push(() =&gt; &#123; console.log(&apos;55&apos;) onfufilled(this.value); &#125;) this.onRejectedCallbacks.push(() =&gt; &#123; console.log(&apos;55&apos;) onrejected(this.reason); &#125;); &#125; &#125; catch(errCallback) &#123; return this.then(null, errCallback); &#125; &#125; 完整版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function resolvePromise(promise2, x, resolve, reject) &#123; // 1)不能引用同一个对象 可能会造成死循环 if (promise2 === x) &#123; return reject(new TypeError(&apos;[TypeError: Chaining cycle detected for promise #&lt;Promise&gt;]----&apos;)); &#125; let called;// promise的实现可能有多个，但都要遵循promise a+规范，我们自己写的这个promise用不上called,但是为了遵循规范才加上这个控制的，因为别人写的promise可能会有多次调用的情况。 // 2)判断x的类型，如果x是对象或者函数，说明x有可能是一个promise，否则就不可能是promise if((typeof x === &apos;object&apos; &amp;&amp; x != null) || typeof x === &apos;function&apos;) &#123; // 有可能是promise promise要有then方法 try &#123; // 因为then方法有可能是getter来定义的, 取then时有风险，所以要放在try...catch...中 // 别人写的promise可能是这样的 // Object.defineProperty(promise, &apos;then&apos;, &#123; // get() &#123; // throw new Error(); // &#125; // &#125;) let then = x.then; if (typeof then === &apos;function&apos;) &#123; // 只能认为他是promise了 // x.then(()=&gt;&#123;&#125;, ()=&gt;&#123;&#125;); 不要这么写，以防以下写法造成报错， 而且也可以防止多次取值 // let obj = &#123; // a: 1, // get then() &#123; // if (this.a++ == 2) &#123; // throw new Error(); // &#125; // console.log(1); // &#125; // &#125; // obj.then; // obj.then // 如果x是一个promise那么在new的时候executor就立即执行了，就会执行他的resolve，那么数据就会传递到他的then中 then.call(x, y =&gt; &#123;// 当前promise解析出来的结果可能还是一个promise, 直到解析到他是一个普通值 if (called) return; called = true; resolvePromise(promise2, y, resolve, reject);// resolve, reject都是promise2的 &#125;, r =&gt; &#123; if (called) return; called = true; reject(r); &#125;); &#125; else &#123; // &#123;a: 1, then: 1&#125; resolve(x); &#125; &#125; catch(e) &#123;// 取then出错了 有可能在错误中又调用了该promise的成功或则失败 if (called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125; 主要就是多了resolvePromise这么一个函数，用来递归处理then内部回调函数执行后的结果，它有4个参数： promise2: 就是新生成的promise，这里至于为什么要把promise2传过来后面会介绍。x: 我们要处理的目标resolve: promise2的resolve, 执行之后promise2的状态就变为成功了，就可以在它的then方法的成功回调中拿到最终结果。reject: promise2的reject, 执行之后promise2的状态就变为失败，在它的then方法的失败回调中拿到失败原因。 Promise的then的第二个参数和catch的区别 reject是用来抛出异常的，catch是用来处理异常的； reject是Promise的方法，而then和catch是Promise实例的方法（Promise.prototype.then 和 Promise.prototype.catch）。 区别 主要区别就是，如果在then的第一个函数里抛出了异常，后面的catch能捕获到，而then的第二个函数捕获不到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const promise = new Promise((resolve, rejected) =&gt; &#123; throw new Error(&apos;test&apos;);&#125;);//此时只有then的第二个参数可以捕获到错误信息promise.then(res =&gt; &#123; //&#125;, err =&gt; &#123; console.log(err);&#125;).catch(err1 =&gt; &#123; console.log(err1);&#125;);//此时catch方法可以捕获到错误信息promise.then(res =&gt; &#123; //&#125;).catch(err1 =&gt; &#123; console.log(err1);&#125;);//此时只有then的第二个参数可以捕获到Promise内部抛出的错误信息promise.then(res =&gt; &#123; throw new Error(&apos;hello&apos;);&#125;, err =&gt; &#123; console.log(err);&#125;).catch(err1 =&gt; &#123; console.log(err1);&#125;);//此时只有then的第二个参数可以捕获到Promise内部抛出的错误信息promise.then(res =&gt; &#123; throw new Error(&apos;hello&apos;);&#125;, err =&gt; &#123; console.log(err);&#125;);//此时catch可以捕获到Promise内部抛出的错误信息promise.then(res =&gt; &#123; throw new Error(&apos;hello&apos;);&#125;).catch(err1 =&gt; &#123; console.log(err1);&#125;); 两个方法的比较 12345678910111213141516// bad 适用于单个 链式的捕捉不到promise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// good promise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xuhongliweb.github.io/tags/js/"}]},{"title":" javascript 中的事件循环 Event Loop","slug":"javascript-中的事件循环-Event-Loop","date":"2020-07-09T01:05:16.000Z","updated":"2020-12-21T14:04:02.012Z","comments":true,"path":"2020/07/09/javascript-中的事件循环-Event-Loop/","link":"","permalink":"https://xuhongliweb.github.io/2020/07/09/javascript-中的事件循环-Event-Loop/","excerpt":"","text":"javascript 为什么是单线程?单线程也就是同一时间只能做一件事, 这也是js 语言的特点,那么为什么不弄个多线程呢? js的单线程与它的用于有关,作为浏览器语言, js,做的是与用户互动,操作DOM,如果是多线程了, 同一时间对一个DOM进行了增加和删除操作,这时候以哪一个为准? 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质 可以看下阮一峰老师的博客 同步与异步同步看下面代码这段代码的实现就叫做同步,也就是说按照顺序去做,做完第一件事情之后,再去做第二件事情 12345console.log(1)for(let i = 0; i&lt; 3; i++)&#123; console.log(i)&#125;console.log(4) 异步 (细分为宏任务和微任务)因为js是单线程的, 当任务多的时候就需要排队, 如果前面一个任务耗时很长, 后面一个任务就要一直等待.所以异步就出现了 宏任务有以下几种：①I/O②setTimeout③setInterval④setImmediate⑤requestAnimationFrame微任务有以下几种：①process.nextTick②MutationObserver③Promise.then catch finally 1234567891011121314console.log(&apos;start&apos;) // 同步setTimeout(() =&gt; &#123; console.log(&apos;宏任务&apos;)&#125;,0)new Promise((reslove) =&gt; &#123; console.log(&apos;p1&apos;) // prpmise 创建 就会立即执行 reslove()&#125;).then(res =&gt; &#123; console.log(&apos;p2&apos;) // &#125;)同步 &gt; 微任务 &gt; 宏任务 1234567891011121314151617console.log(&apos;start&apos;) // 同步setTimeout(() =&gt; &#123; console.log(&apos;宏任务&apos;)&#125;,2220)for (let index = 0; index &lt; 22000; index++) &#123;console.log(&apos;index&apos;) // setTimeout 的延时时间,取决与同步函数的运行时间, 这里登 延时函数运行的时候会立即输出&#125;new Promise((reslove) =&gt; &#123; console.log(&apos;p1&apos;) // prpmise 创建 就会立即执行 reslove()&#125;).then(res =&gt; &#123; console.log(&apos;then&apos;) // &#125;) 这个和上面的差不多, 只要理解了一个就面的也就理解了, 1234567891011121314151617181920212223console.log(&apos;start&apos;) // 同步setTimeout(() =&gt; &#123; console.log(&apos;宏任务&apos;) new Promise((reslove) =&gt; &#123; console.log(&apos;setTimeout p1&apos;) // prpmise 创建 就会立即执行 reslove() &#125;).then(res =&gt; &#123; console.log(&apos; setTimeout then&apos;) // &#125;)&#125;, 2220)for (let index = 0; index &lt; 22000; index++) &#123; console.log(&apos;index&apos;)&#125;new Promise((reslove) =&gt; &#123; console.log(&apos;p1&apos;) // prpmise 创建 就会立即执行 reslove()&#125;).then(res =&gt; &#123; console.log(&apos;then&apos;) // &#125;) 记住JS是单线程的, 任务也是一个一个取的 123456789let i = 0setTimeout(() =&gt; &#123; // 扔到任务队列 =&gt; 依次执行 i = 1 console.log(i++)&#125;,1000)setTimeout(() =&gt; &#123; // 扔到任务队列 =&gt; 依次执行 i = 2 console.log(i++)&#125;,1000) 任务队列(消息队列)任务队列是一个事件的队列(也可以理解成消息的队列)工作线程完成一项任务，就在”任务队列”中添加一个事件(也可以理解为发送一条消息)，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 所有同步任务都在主线程上执行，形成一个执行栈 主线程发起异步请求,相应的工作线程就会去执行异步任务 主线程可以继续执行后面的代码 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队 主线程把当前的事件执行完成之后,再去读取任务队列,如此反复重复 总结主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环） 代码从上到下执行, 优先执行同步函数, 在遇到异步函数时将该任务推入执行栈,当任务队列中没有同步任务,便开始从执行栈中取异步函数, 顺序是 微任务 &gt; 宏任务","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xuhongliweb.github.io/tags/js/"}]},{"title":"闭包","slug":"闭包","date":"2020-07-04T00:08:08.000Z","updated":"2020-12-21T14:04:02.012Z","comments":true,"path":"2020/07/04/闭包/","link":"","permalink":"https://xuhongliweb.github.io/2020/07/04/闭包/","excerpt":"","text":"闭包是什么？ 闭包是指有权访问另一个函数作用域的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。 说起闭包就不得不聊聊作用域 闭包与变量对象和作用域链有着比较多的联系全局环境只能访问全局中定义的变量和方法, 不能直接访问局部环境中的方法和变量123456var title = &apos;blog&apos;function test() &#123; console.log(&apos;title&apos;) var u = &apos;uuu&apos;&#125;test() // 每调用一次都会在内存中开辟一个环境, 结束之后就销毁(变量不在被引用) 每调用一次都会在内存中开辟一个环境, 结束之后就销毁(变量不在被引用就会被回收)延长作用域链来实现让X的值每次调用都加11234567891011由于每次调用都会在内存中开辟新的地址, 最重要的是里面的变量没被引用, 所以在结束之后就会被销毁. 不能实现累加效果function add () &#123; var x = 0 function sum() &#123; console.log(++x) &#125; sum()&#125;add()add() // 这样改造下 12345678910由add 返回的匿名函数一直在使用变量X,(利用闭包特性) 这样也就不会被销毁了, 在特定时候把add 设为 null 手动回收把 function add () &#123; var x = 0 return function () &#123; console.log(++x) &#125;&#125;var a = add()a()a() 什么是块级作用域?在ES6之前是没有块级作用域的, 不像 let const 这样 {} 外部不可以访问到里面的函数和变量 123456&#123; let b = 2 const c = 3&#125;console.log(b) // 不可以console.log(c) 不可以 在之前 这些变量添加到当前执行环境 在这里是全局环境 也就是window 在for 循环中尤为重要 1234567891011121314151617181920212223242526if(true) &#123; var b = 2 var c = 3&#125;console.log(b)console.log(c)for(var i = 0; i &lt; 3; i++)&#123; // 沿着作用域向上找 由于没有块级作用域 , 直接找到window 上的i setTimeout( function()&#123; console.log(i)gvnd &#125; ,1000)&#125;console.log(i,&apos;win&apos;)// 在定时器了输出d对应的jfor(var j = 0 ;j &lt; 3 ; j++) &#123; // 没有 变量作用域, 有函数作用域 利用每创建一个函数就会创建一个内存空间 (function(n)&#123; console.log(n) &#125;)(j)&#125; 应用12345678910111213// 应用let arr = [1,43,543,543,534,24,2,623,42,2132,35342,21,53,21,3,53,3,54,66]function f(a,b) &#123; return function (v) &#123; return v &gt; a &amp;&amp; v&lt; b &#125;&#125;console.log(arr.filter(f(0,100))) console.log(arr.filter(f(100,600))) 关于this在闭包中使用this对象可能会有一些问题, this 是在运行时基于环境绑定的. 在全局环境中 this 等于 window, 而当函数被当作某个对象的方法被调用时, this 等于那个对象, 不过匿名函数执行环境具有全局性, 因此this 对象通常指向window, 12345678// var obj = &#123;// name : &apos;obj1&apos;,// getName () &#123;// return this.name// &#125;// &#125;// console.log(obj.getName()) //正常 12345678910var obj = &#123; name : &apos;obj1&apos;, getName:function () &#123; return function ()&#123; return this.name &#125; &#125;&#125;console.log(obj.getName()()) // window 匿名函数执行环境具有全局性 怎么解决呢 1 利用作用域链, 在函数里面定义 正确的 this 变量,2 箭头函数 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 3 bind call apply // console.log(obj.getName().bind(obj)())// console.log(obj.getName().apply(obj))// console.log(obj.getName().call(obj)) 造成内存泄漏12345678910111213141516171819// 内存泄漏 function dom () &#123; var ele = document.querySelectorAll(&apos;.test&apos;) ele.onclick = function () &#123; console.log(ele.id) // 循环引用 &#125;&#125;// 优化 function dom () &#123; var ele = document.querySelectorAll(&apos;.test&apos;) var id = ele.id ele.onclick = function () &#123; console.log(id) // 循环引用 &#125; ele = null&#125; 总结闭包的常见的使用形式 返回一个函数 作为函数参数传递 回调函数 非典型闭包IIFE(立即执行函数表达式) 闭包结合了局部变量和全局变量的优点。可以使变量不污染全局，但是又能对变量进行重用。但是，其实闭包也有有缺点的，它比起普通函数会占用更多的内存。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://xuhongliweb.github.io/tags/js/"}]},{"title":"echart-bar","slug":"echart-bar","date":"2020-06-19T12:05:25.000Z","updated":"2020-12-21T14:04:02.011Z","comments":true,"path":"2020/06/19/echart-bar/","link":"","permalink":"https://xuhongliweb.github.io/2020/06/19/echart-bar/","excerpt":"","text":"echart 柱状图带背景且柱状条顶端显示文字的效果 实现方式第一种隐藏X轴，左侧文字用Y轴右侧用label标签 由于柱状图的背景颜色新增的数据， 所以在显示和hover的时候都要处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647yAxis: &#123; // 左侧柱状图的Y轴 splitLine: &apos;none&apos;, axisTick: &apos;none&apos;, axisLine: &apos;none&apos;, axisLabel: &#123; verticalAlign: &apos;top&apos;, align: &apos;center&apos;, padding: [-5, 50, 10, 15], textStyle: &#123; color: &apos;#333&apos;, fontSize: &apos;14&apos; &#125; &#125;, data: [&apos;站三&apos;, &apos;里斯&apos;, &apos;王二&apos;] // inverse: true &#125;, // 背景数据 // 背景 &#123; barGap: &apos;-100%&apos;, // Make series be overlap name: &apos;&apos;, type: &apos;bar&apos;, barWidth: 15, silent: true, // 关键 itemStyle: &#123; color: &apos;#F6F5FA&apos;, barBorderRadius: 6 &#125;, label: &#123; // 右侧文字 show: true, // 通过formatter函数来返回想要的数据 formatter: function (params) &#123; // 关键 for (let i = 0; i &lt; data.length; i++) &#123; if (params.dataIndex === i) &#123; return data[i] + &apos;人&apos; &#125; &#125; &#125;, position: &apos;right&apos;, textStyle: &#123; color: &apos;#333&apos; &#125; &#125;, data: [654, 654, 654] &#125;, ]","categories":[{"name":"web前端","slug":"web前端","permalink":"https://xuhongliweb.github.io/categories/web前端/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xuhongliweb.github.io/tags/js/"}]},{"title":"防抖和节流","slug":"防抖和节流","date":"2019-10-16T09:13:45.000Z","updated":"2020-12-21T14:04:02.013Z","comments":true,"path":"2019/10/16/防抖和节流/","link":"","permalink":"https://xuhongliweb.github.io/2019/10/16/防抖和节流/","excerpt":"","text":"防抖和节流在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，用户体验非常差 此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 那么什么时候用防抖什么时候用节流呢借用github上一位大佬说的就像一窝蜂的人去排队看演出，队伍很乱，看门的老大爷每隔1秒，让进一个人，这个叫throttle，如果来了这一窝蜂的人，老大爷一次演出只让进一个人，下次演出才让下一个人进，这个就叫debounce（如果用onresize类比，就是鼠标mousedown，然后疯狂缩放窗口，然后鼠标mouseup，这整个过程就是一次演出，这次演出只允许一个人看即只执行一次回调）。 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。 按一个按钮发送 AJAX：给 click 加了 debounce 后就算用户不停地点这个按钮，也只会最终发送一次；如果是 throttle 就会间隔发送几次 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次 节流 函数节流的原理挺简单的，一种方式是定时器。当我触发一个时间时，先setTimeOut让这个时间延迟一会执行，如果在这个时间间隔内又触发了事件。那我们就清除了原来的定时器。在setTimeout一个新的定时器延迟一会执行函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。 throttle 应用场景 DOM 元素的拖拽功能实现（mousemove） 计算鼠标移动的距离（mousemove） 搜索联想（keyup） 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次 123456789101112131415161718192021/** * @author * @description 节流第一次会触发 最后一次不会触发 */export const _throttle = function(func, wait) &#123; var prev = 0 return function() &#123; var context = this var args = arguments var now = +new Date() if (now - prev &gt; wait) &#123; // 第一次肯定执行 把上一次 的 now 复制给 prev // 第二次 生成新的时间戳 减去 上一次的 如果大于等于间隔事件就执行。反之不执行 // 重复 以上操作 func.apply(context, args) prev = now &#125; &#125;&#125; /** @param {*} wait @param {*} func @description 第一次不会触发 最后一次会触发prev = 0now = 10wait 2第一次 prev 10第二次 num 13 - 10 》 wait 成立 prev = 13 … 循环下去 / export const _throttle2 = function (func,wait) { let context,timer,args; return function () { context = this args = arguments if(!timer) { // 在这里区别 timer = setTimeout(() =&gt; { timer = null func.apply(context,args) }, wait); } }}运行结果： 我们既想首次调用，也要最后触发。 把两者结合下 123456789101112131415161718192021222324252627282930313233343536373839404142 /** * @description 两者结合 * 长按由于更新了时间不满足时间戳走了定时器？ prev = 0 now = 10 wait 2 第一次 prev 10 2 秒钟 后是 12 在2秒内的连点不会触发执行 连点由于第一个条件不成立，一直走定时器的 ... 循环下去 * */export const throttle3 = function (func,wait) &#123; let timer,context,prev = 0,now,args; return function () &#123; context = this args = arguments now = +new Date() if(now - prev &gt; wait) &#123; console.log(now - prev &gt; wait, &apos;now - prev&apos;) // debugger console.log(&apos;时间戳&apos;) if(timer)&#123; // 结束后重新计算时间 clearTimeout(timer) timer = null &#125; func.apply(context,args) prev = now &#125;else if(!timer)&#123; console.log(&apos;定时器&apos;) console.log(now - prev &gt; wait, &apos;now - prev&apos;) // debugger timer = setTimeout(() =&gt; &#123; prev = +new Date() // 重置前一次触发的时间戳 func.apply(context, args) timer = null &#125;, wait); &#125; &#125;&#125; 通过选项来控制 头部调用还是尾部调用 12345678910111213141516171819202122232425262728293031323334/** * 完整版 的 节流 * @param &#123;object&#125; option * 如果您想禁用前沿呼叫，请传递&#123;leading：false&#125;，并且如果您要禁用后沿执行，请传递 &#123;trailing: false&#125;. */ export const _throttle4 = function (func,wait,option) &#123; let context,timer,args,now,prev = 0; if(!option) &#123;option = &#123;&#125;&#125; return function () &#123; context = this now = +new Date() args = arguments console.log(option, &apos;option&apos;) if(option.leading === false) &#123; prev = now // 禁用首次执行 &#125; if(now - prev &gt; wait) &#123; if(timer) &#123; clearTimeout(timer) timer = null &#125; func.apply(context,args) prev = now &#125;else if(!timer &amp;&amp; option.trailing !== false) &#123; timer = setTimeout(() =&gt; &#123; timer = null func.apply(context, args) prev = +new Date() &#125;, wait); &#125; &#125; &#125; 运行结果： input 中的节流的应用 123456789101112131415161718 &lt;div&gt; &lt;vx-input v-model=&quot;key&quot; ref=&quot;inp&quot; /&gt; &lt;vx-button ref=&quot;btn&quot;&gt;搜索&lt;/vx-button&gt; &lt;/div&gt;import &#123;_throttle3,_throttle,_throttle2,_throttle4&#125; from &apos;lib/utils&apos;mounted()&#123; const inp = this.$refs.inp.$el const btn = this.$refs.btn.$el console.log(inp) const that = this const op = &#123; leading:false, // 禁用首次执行 trailing:true &#125; // 节流 inp.addEventListener(&apos;input&apos;,_throttle4(that.searchInp,2000,op)) btn.addEventListener(&apos;click&apos;,_throttle(that.searchInp,1000)) &#125;, 其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。 防抖防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件， debounce 应用场景 每次 resize/scroll 触发统计事件 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好） 当持续触发事件，一定时间内没有再触发事件，事件会重新执行一次红宝书》给出了最简洁最经典的去抖代码（书中说是节流，实则为去抖），调用如下 12345678910111213141516function debounce(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(context); &#125;, 1000);&#125;function print() &#123; console.log(&apos;hello world&apos;);&#125;window.onscroll = function() &#123; debounce(print);&#125;;在窗口内滚动一次，停止，1000ms 后，打印了 hello world，因为我们设置了一个 1000ms 延迟的定时器，细思非常巧妙。连续触发事件， 在结束后只触发一次 1234567891011debounce(fn, delay) &#123; let timer; return function() &#123; let that = this, arg = arguments; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(that, arg); &#125;, delay); &#125;; &#125;, /** @author @description /export const _debounce1 = function (method,wait = 1000) {let timer = nulllet n = 0return function () { let that = this let arg = arguments clearTimeout(timer) timer = setTimeout(function() { method.apply(that,arg) },wait) console.log(n++)}}/** @description 第2版 支持立即执行的选项 对立即参数传递true 以使debounce触发前导函数而不是等待间隔的后沿。在防止意外双击“提交”按钮从而再次发射的情况下很有用。 / export const _debounce2 = function (func,wait,immediate) { let context,args,timer; return function () { context = this args = arguments if (timer) clearTimeout(timer); // 如果immediate 为 true 先执行一次 if(immediate) { var callNow = !timer timer = setTimeout(() =&gt; { timer = null }, wait); if(callNow) { func.apply(context, args) } }else { timer = setTimeout(() =&gt; { func.apply(context,args) }, wait); } }}以上调用方法： 12// 防抖 inp.addEventListener(&apos;input&apos;,debounce(that.searchInp,2000,true)) 运行结果： 可以看出来， 持续触发事件，会被清楚， 只有最后一次事件触发过后，等待指定延时时间后在执行的.","categories":[{"name":"web前端","slug":"web前端","permalink":"https://xuhongliweb.github.io/categories/web前端/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xuhongliweb.github.io/tags/js/"}]},{"title":"axios-cancelToken 总结","slug":"axios-cancelToken-总结","date":"2019-10-08T09:13:45.000Z","updated":"2020-12-21T14:04:02.011Z","comments":true,"path":"2019/10/08/axios-cancelToken-总结/","link":"","permalink":"https://xuhongliweb.github.io/2019/10/08/axios-cancelToken-总结/","excerpt":"","text":"在vue 项目中我们通常会使用axios 来请求接口。在项目中遇到列表切换，防止快速多次点击列表导致请求频繁发送等等减轻服务器压力cancelToken取消请求就是一方案。 在ajax时代是用的abort()来取消接口请求的。 当然也有其他方法比如：节流、按钮置灰等等 基本用法看下官网的基本用法[cancelToken 取消请求] (http://www.axios-js.com/zh-cn/docs/#%E5%8F%96%E6%B6%88) 官网方法一1234567891011121314151617181920212223242526272829var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token // 标记&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; // 主动取消的在这可以捕捉到 &#125; else &#123; // 处理错误 &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel(&apos;Operation canceled by the user.&apos;);// post 取消请求axios.post(&apos;/user/123/&apos;,&#123; name:x&#125;,&#123; cancelToken:source.token // 是在第三个地方添加 &#125;).then(res =&gt; &#123; // 成功&#125;).catch(err =&gt; &#123; if(axios.isCancel(err))&#123; // 主动取消 &#125;else &#123; //其他错误 &#125;&#125;) 官网方法 二 可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：1234567891011const ConcelToken = axios.CancelTokenlet cancelaxios.get(&apos;/user/12345&apos;, &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// cancel the requestcancel(); ##看下在项目中如何使用 防止重复请求在做项目时会遇到用户连点按钮的情况造成服务器压力或是未知异常等， 为了避免这种情况可以给用户一个友好的提示，多次请求只有最后一次有效 1234567891011121314151617181920212223sendRequest() &#123; let that = this; if(this.cancelList)&#123; this.cancelList.cancel(&apos;我取消啦&apos;) &#125; this.cancelList = axios.CancelToken.source(); axios.get(&apos;http://jsonplaceholder.typicode.com/comments&apos;, &#123; cancelToken:that.cancelList.token &#125;) .then(res =&gt; &#123; // 你的逻辑 this.list = res &#125;) .catch(thrown =&gt; &#123; if (axios.isCancel(thrown)) &#123; // 如果调用了cancel方法，那么这里的res就是cancel传入的信息 alert(&apos;请不要点击过于频繁&apos;) &#125; else &#123; // 处理错误 alert(&apos;接收400 401 等其他错误&apos;) console.log(&apos;处理错误&apos;, thrown.message); &#125; &#125;) &#125;, 我们可以把他封装起来 1234567891011121314151617181920212223242526const clearHttpPendingList = (config) =&gt; &#123; Vue.prototype.pending.forEach((item, index) =&gt; &#123; if (config.url === item.url) &#123; item.c(); Vue.prototype.pending.splice(index, 1); &#125; if (config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;) &amp;&amp; localStorage.getItem(&apos;comments&apos;)) &#123; // 不同页面相同的接口 Vue.prototype.pending.splice(index, 1); &#125; &#125;);&#125;;axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;); 连续点后它的网络请求 取消上一个页面的pedding请求优化性能， 跳转之前取消 正在请求的接口 1234567891011121314151617181920212223Vue.prototype.pending = []; // //声明一个数组用于存储每个ajax请求的取消函数和ajax标识 请求的缓存axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;);router.afterEach((to, from) =&gt; &#123; Vue.prototype.pending.forEach((item) =&gt; &#123; item.c(); &#125;); Vue.prototype.pending = [];&#125;); 这个接口处于pedding状态跳转到其他页面取消 相同的接口不再调用的应用-项目中有的接口在多个页面调用， 这个接口返回的数据不会轻易改变。 这个时候我们就会用到这个canceltoken和页面缓存。比如这个重复接口是A， 思路是 先调用A接口然后把接口内容存到本地， 这样在任何页面调用A接口的时候就直接取消掉了， 看下代码 12345678910111213141516171819202122232425262728293031323334353637axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;);axios.interceptors.response.use( (response) =&gt; &#123; if (response.config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;)) &#123; localStorage.setItem(&apos;comments&apos;, JSON.stringify(response.data)); &#125; // comments 要缓存的接口 clearHttpPendingList(response.config); //在一个ajax响应后再执行一下取消操作，把已经完成的请求从pending中移除 // 响应成功的数据 return response; &#125;)const clearHttpPendingList = (config) =&gt; &#123; Vue.prototype.pending.forEach((item, index) =&gt; &#123; if (config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;) &amp;&amp; localStorage.getItem(&apos;comments&apos;)) &#123; // 不同页面相同的接口 item.c(); Vue.prototype.pending.splice(index, 1); &#125; &#125;);&#125;;","categories":[{"name":"web前端","slug":"web前端","permalink":"https://xuhongliweb.github.io/categories/web前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://xuhongliweb.github.io/tags/vue/"}]},{"title":"前言","slug":"前言","date":"2019-09-22T09:01:32.000Z","updated":"2020-12-21T14:04:02.012Z","comments":true,"path":"2019/09/22/前言/","link":"","permalink":"https://xuhongliweb.github.io/2019/09/22/前言/","excerpt":"","text":"关于前端-算法先说下自己不是科班出身 ，在工作的过程中深深的体会到算法的重要性，如果写的很差会导致程序运行很慢。。， 如何学习算法多看、多练、多思考。 多看 推荐《算法图解》《啊哈！算法》 新手 多练 leetCoce 、 牛客 https://leetcode-cn.com 多思考 养成总结的习惯，懂得变通。养成良好的思维方式 关于更新因为没太多时间更新在加上自己也处于学习阶段， 更新会比较慢。 希望自己能写出健壮、快速、精简的代码。共勉","categories":[{"name":"web前端","slug":"web前端","permalink":"https://xuhongliweb.github.io/categories/web前端/"}],"tags":[{"name":"leetCode","slug":"leetCode","permalink":"https://xuhongliweb.github.io/tags/leetCode/"}]},{"title":"singleNumber","slug":"singleNumber","date":"2019-09-22T05:45:38.000Z","updated":"2020-12-21T14:04:02.012Z","comments":true,"path":"2019/09/22/singleNumber/","link":"","permalink":"https://xuhongliweb.github.io/2019/09/22/singleNumber/","excerpt":"","text":"只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/single-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解法1 应该是最慢的方法。。。违背了题意刚看到这个题的时候我以为是用对象就出结果了，尴尬。然后仔细想了下这不是消消乐那种嘛，虽然不怎么玩，但是想起来简单做起来难， 我第一次的解法确实最繁琐的。解法是利用了很多外部空间是数组加对象 利用数组判断出每个数字的循环次数 再用对象找出最小的那个。。。123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums[0]; &#125; let map = &#123;&#125;; let n = 1; let res = &apos;&apos;; for (let i = 0; i &lt; nums.length; i++) &#123; n = 1; for (let j = 0; j &lt; nums.length; j++) &#123; if (nums[i] === nums[j]) &#123; map[nums[i]] = n++; &#125; &#125; &#125; console.log(map, &apos;map&apos;); let min = 1; for (let key in map) &#123; if (map[key] &lt; min) &#123; min = map[key]; &#125; console.log(min, &apos;min&apos;); if (map[key] === min) &#123; res = key; &#125; &#125; console.log(res); return res;&#125;;let t = [ 2, 1, 2 ];let t1 = [ 4, 1, 2, 1, 2 ];singleNumber(t); 然后运行时长看图： 解法2 新建对象 相同的就删除 12345678910111213141516var singleNumber1 = function(nums) &#123; var obj = &#123;&#125;; for (let i = 0; i &lt; nums.length; i++) &#123; obj[nums[i]] = !obj[nums[i]]; if (!obj[nums[i]]) &#123; delete obj[nums[i]]; &#125; &#125; console.log(obj); return Object.keys(obj)[0];&#125;;let t = [ 2, 1, 2 ];let t1 = [ 4, 1, 2, 1, 2 ];let t2 = [ 1, 3, 1, -1, 3 ];singleNumber1(t1); 运行图解-第一次用这个软件 运行时长 一些大神的解法 ：解法3 因为 除了某个元素只出现一次以外，其余每个元素均出现两次， 所以我们可以先排序，在以2为基数循环 第一步先排序 冒号排序972ms…, 自带的排序88ms 以2为基数每次循环 因为是排好序的又是相同的是两两出现当前的不等于后一个就是唯一的，如果没有找到不相等的就返回最后一个 12345678910111213141516171819202122var singleNumber2 = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums[0]; &#125; let tmp = 0; // 排序 for (let i = 0; i &lt; nums.length; i++) &#123; for (let j = 0; j &lt; nums.length - i - 1; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; &#125; &#125; &#125; for (let i = 0; i &lt; nums.length; i += 2) &#123; if (nums[i] != nums[i + 1]) &#123; return nums[i]; &#125; &#125; return nums[nums.length - 1];&#125;; 运行时长： 解法三 异或运算先来看下异或运算的描述 任何数与0异或都不会改变他的数值 x ^ 0 = x 任何数与自身异都为0 x^x = 0 正好利用以上两点完美的解决。 12345678var singleNumber = function(nums) &#123; let num = 0; for (let i = 0; i &lt; nums.length; i++) &#123; num = num ^ nums[i]; &#125; console.log(num); return num;&#125;; 执行时长","categories":[{"name":"web前端","slug":"web前端","permalink":"https://xuhongliweb.github.io/categories/web前端/"}],"tags":[{"name":"leetCode","slug":"leetCode","permalink":"https://xuhongliweb.github.io/tags/leetCode/"}]},{"title":"first","slug":"HelloHexo","date":"2019-09-18T02:12:11.000Z","updated":"2020-12-21T14:04:02.010Z","comments":true,"path":"2019/09/18/HelloHexo/","link":"","permalink":"https://xuhongliweb.github.io/2019/09/18/HelloHexo/","excerpt":"","text":"第一篇文章 Hello hexo发布流程新建1hexo new &quot;hello-world&quot; 创建tags1hexo new page tags 参考链接 https://www.jianshu.com/p/e17711e44e00Hexo使用攻略-添加分类及标签 执行命令1hexo g 发布到github12hexo cleanhexo g -d","categories":[{"name":"web前端","slug":"web前端","permalink":"https://xuhongliweb.github.io/categories/web前端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xuhongliweb.github.io/tags/hexo/"}]}],"categories":[{"name":"web前端","slug":"web前端","permalink":"https://xuhongliweb.github.io/categories/web前端/"}],"tags":[{"name":"js","slug":"js","permalink":"https://xuhongliweb.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://xuhongliweb.github.io/tags/vue/"},{"name":"leetCode","slug":"leetCode","permalink":"https://xuhongliweb.github.io/tags/leetCode/"},{"name":"hexo","slug":"hexo","permalink":"https://xuhongliweb.github.io/tags/hexo/"}]}