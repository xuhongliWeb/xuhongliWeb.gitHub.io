<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2020%2F12%2F20%2FPromise%2F</url>
    <content type="text"><![CDATA[Promise 是什么？Promise 是异步编程的一种解决方案，比传统的方案一一回调更合理更强大。 所谓Promise ,简单来说。里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果从语法上说 。 Promise 是一个对象， 从它可以获取异步操作的消息。Promise提供的API，各种异步操作都可以用通用的方法处理 。 Promise 对象有两个特点 对象的状态不受外界影响Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 一旦状态改变。就不会在变 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echart-bar]]></title>
    <url>%2F2020%2F06%2F19%2Fechart-bar%2F</url>
    <content type="text"><![CDATA[echart 柱状图带背景且柱状条顶端显示文字的效果 实现方式第一种隐藏X轴，左侧文字用Y轴右侧用label标签 由于柱状图的背景颜色新增的数据， 所以在显示和hover的时候都要处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647yAxis: &#123; // 左侧柱状图的Y轴 splitLine: &apos;none&apos;, axisTick: &apos;none&apos;, axisLine: &apos;none&apos;, axisLabel: &#123; verticalAlign: &apos;top&apos;, align: &apos;center&apos;, padding: [-5, 50, 10, 15], textStyle: &#123; color: &apos;#333&apos;, fontSize: &apos;14&apos; &#125; &#125;, data: [&apos;站三&apos;, &apos;里斯&apos;, &apos;王二&apos;] // inverse: true &#125;, // 背景数据 // 背景 &#123; barGap: &apos;-100%&apos;, // Make series be overlap name: &apos;&apos;, type: &apos;bar&apos;, barWidth: 15, silent: true, // 关键 itemStyle: &#123; color: &apos;#F6F5FA&apos;, barBorderRadius: 6 &#125;, label: &#123; // 右侧文字 show: true, // 通过formatter函数来返回想要的数据 formatter: function (params) &#123; // 关键 for (let i = 0; i &lt; data.length; i++) &#123; if (params.dataIndex === i) &#123; return data[i] + &apos;人&apos; &#125; &#125; &#125;, position: &apos;right&apos;, textStyle: &#123; color: &apos;#333&apos; &#125; &#125;, data: [654, 654, 654] &#125;, ]]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2F2019%2F10%2F16%2F%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖和节流在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，用户体验非常差 此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 那么什么时候用防抖什么时候用节流呢 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。 一般页面频繁滚动时用节流， 页面里有个频繁触发的搜索框用防抖 节流 两种方式时间戳版 12345678910111213throttle(fn, delay = 500) &#123; let previous = 0; return function() &#123; let now = Date.now(); let context = this; let args = arguments; if (now - previous &gt; delay) &#123; fn.apply(context, args); // previous = now; &#125; &#125;;&#125; 运行结果： 定时器版 1234567891011121314151617/** * 调用这个方法一秒后才会执行， 之后没每隔delay秒运行一次函数 * 当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。 */ throttle_timer(fn, delay) &#123; let timer; return function() &#123; let that = this; let arg = arguments; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; timer = null; fn.apply(that, arg); &#125;, delay); &#125; &#125;; &#125;, 运行结果： 其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。 防抖当持续触发事件，一定时间内没有再触发事件，事件会重新执行一次 1234567891011debounce(fn, delay) &#123; let timer; return function() &#123; let that = this, arg = arguments; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(that, arg); &#125;, delay); &#125;; &#125;, 运行结果： 以上调用方法： 12345678910111213initSearch() &#123; const searchDom = this.$refs.inp; const that = this; // searchDom.addEventListener( // &quot;input&quot;, // that.throttle_timer(that.search, 1000) // ); searchDom.addEventListener( &quot;input&quot;, that.debounce(that.search, 500) ); // searchDom.addEventListener(&quot;input&quot;,that.throttle(that.search,5000))&#125;, 可以看出来， 持续触发事件，会被清楚， 只有最后一次事件触发过后，等待指定延时时间后在执行的.]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios-cancelToken 总结]]></title>
    <url>%2F2019%2F10%2F08%2Faxios-cancelToken-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在vue 项目中我们通常会使用axios 来请求接口。在项目中遇到列表切换，防止快速多次点击列表导致请求频繁发送等等减轻服务器压力cancelToken取消请求就是一方案。 在ajax时代是用的abort()来取消接口请求的。 当然也有其他方法比如：节流、按钮置灰等等 基本用法看下官网的基本用法[cancelToken 取消请求] (http://www.axios-js.com/zh-cn/docs/#%E5%8F%96%E6%B6%88) 官网方法一1234567891011121314151617181920212223242526272829var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token // 标记&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; // 主动取消的在这可以捕捉到 &#125; else &#123; // 处理错误 &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel(&apos;Operation canceled by the user.&apos;);// post 取消请求axios.post(&apos;/user/123/&apos;,&#123; name:x&#125;,&#123; cancelToken:source.token // 是在第三个地方添加 &#125;).then(res =&gt; &#123; // 成功&#125;).catch(err =&gt; &#123; if(axios.isCancel(err))&#123; // 主动取消 &#125;else &#123; //其他错误 &#125;&#125;) 官网方法 二 可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：1234567891011const ConcelToken = axios.CancelTokenlet cancelaxios.get(&apos;/user/12345&apos;, &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// cancel the requestcancel(); ##看下在项目中如何使用 防止重复请求在做项目时会遇到用户连点按钮的情况造成服务器压力或是未知异常等， 为了避免这种情况可以给用户一个友好的提示，多次请求只有最后一次有效 1234567891011121314151617181920212223sendRequest() &#123; let that = this; if(this.cancelList)&#123; this.cancelList.cancel(&apos;我取消啦&apos;) &#125; this.cancelList = axios.CancelToken.source(); axios.get(&apos;http://jsonplaceholder.typicode.com/comments&apos;, &#123; cancelToken:that.cancelList.token &#125;) .then(res =&gt; &#123; // 你的逻辑 this.list = res &#125;) .catch(thrown =&gt; &#123; if (axios.isCancel(thrown)) &#123; // 如果调用了cancel方法，那么这里的res就是cancel传入的信息 alert(&apos;请不要点击过于频繁&apos;) &#125; else &#123; // 处理错误 alert(&apos;接收400 401 等其他错误&apos;) console.log(&apos;处理错误&apos;, thrown.message); &#125; &#125;) &#125;, 我们可以把他封装起来 1234567891011121314151617181920212223242526const clearHttpPendingList = (config) =&gt; &#123; Vue.prototype.pending.forEach((item, index) =&gt; &#123; if (config.url === item.url) &#123; item.c(); Vue.prototype.pending.splice(index, 1); &#125; if (config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;) &amp;&amp; localStorage.getItem(&apos;comments&apos;)) &#123; // 不同页面相同的接口 Vue.prototype.pending.splice(index, 1); &#125; &#125;);&#125;;axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;); 连续点后它的网络请求 取消上一个页面的pedding请求优化性能， 跳转之前取消 正在请求的接口 1234567891011121314151617181920212223Vue.prototype.pending = []; // //声明一个数组用于存储每个ajax请求的取消函数和ajax标识 请求的缓存axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;);router.afterEach((to, from) =&gt; &#123; Vue.prototype.pending.forEach((item) =&gt; &#123; item.c(); &#125;); Vue.prototype.pending = [];&#125;); 这个接口处于pedding状态跳转到其他页面取消 相同的接口不再调用的应用-项目中有的接口在多个页面调用， 这个接口返回的数据不会轻易改变。 这个时候我们就会用到这个canceltoken和页面缓存。比如这个重复接口是A， 思路是 先调用A接口然后把接口内容存到本地， 这样在任何页面调用A接口的时候就直接取消掉了， 看下代码 12345678910111213141516171819202122232425262728293031323334353637axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;);axios.interceptors.response.use( (response) =&gt; &#123; if (response.config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;)) &#123; localStorage.setItem(&apos;comments&apos;, JSON.stringify(response.data)); &#125; // comments 要缓存的接口 clearHttpPendingList(response.config); //在一个ajax响应后再执行一下取消操作，把已经完成的请求从pending中移除 // 响应成功的数据 return response; &#125;)const clearHttpPendingList = (config) =&gt; &#123; Vue.prototype.pending.forEach((item, index) =&gt; &#123; if (config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;) &amp;&amp; localStorage.getItem(&apos;comments&apos;)) &#123; // 不同页面相同的接口 item.c(); Vue.prototype.pending.splice(index, 1); &#125; &#125;);&#125;;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[关于前端-算法先说下自己不是科班出身 ，在工作的过程中深深的体会到算法的重要性，如果写的很差会导致程序运行很慢。。， 如何学习算法多看、多练、多思考。 多看 推荐《算法图解》《啊哈！算法》 新手 多练 leetCoce 、 牛客 https://leetcode-cn.com 多思考 养成总结的习惯，懂得变通。养成良好的思维方式 关于更新因为没太多时间更新在加上自己也处于学习阶段， 更新会比较慢。 希望自己能写出健壮、快速、精简的代码。共勉]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[singleNumber]]></title>
    <url>%2F2019%2F09%2F22%2FsingleNumber%2F</url>
    <content type="text"><![CDATA[只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/single-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解法1 应该是最慢的方法。。。违背了题意刚看到这个题的时候我以为是用对象就出结果了，尴尬。然后仔细想了下这不是消消乐那种嘛，虽然不怎么玩，但是想起来简单做起来难， 我第一次的解法确实最繁琐的。解法是利用了很多外部空间是数组加对象 利用数组判断出每个数字的循环次数 再用对象找出最小的那个。。。123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums[0]; &#125; let map = &#123;&#125;; let n = 1; let res = &apos;&apos;; for (let i = 0; i &lt; nums.length; i++) &#123; n = 1; for (let j = 0; j &lt; nums.length; j++) &#123; if (nums[i] === nums[j]) &#123; map[nums[i]] = n++; &#125; &#125; &#125; console.log(map, &apos;map&apos;); let min = 1; for (let key in map) &#123; if (map[key] &lt; min) &#123; min = map[key]; &#125; console.log(min, &apos;min&apos;); if (map[key] === min) &#123; res = key; &#125; &#125; console.log(res); return res;&#125;;let t = [ 2, 1, 2 ];let t1 = [ 4, 1, 2, 1, 2 ];singleNumber(t); 然后运行时长看图： 解法2 新建对象 相同的就删除 12345678910111213141516var singleNumber1 = function(nums) &#123; var obj = &#123;&#125;; for (let i = 0; i &lt; nums.length; i++) &#123; obj[nums[i]] = !obj[nums[i]]; if (!obj[nums[i]]) &#123; delete obj[nums[i]]; &#125; &#125; console.log(obj); return Object.keys(obj)[0];&#125;;let t = [ 2, 1, 2 ];let t1 = [ 4, 1, 2, 1, 2 ];let t2 = [ 1, 3, 1, -1, 3 ];singleNumber1(t1); 运行图解-第一次用这个软件 运行时长 一些大神的解法 ：解法3 因为 除了某个元素只出现一次以外，其余每个元素均出现两次， 所以我们可以先排序，在以2为基数循环 第一步先排序 冒号排序972ms…, 自带的排序88ms 以2为基数每次循环 因为是排好序的又是相同的是两两出现当前的不等于后一个就是唯一的，如果没有找到不相等的就返回最后一个 12345678910111213141516171819202122var singleNumber2 = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums[0]; &#125; let tmp = 0; // 排序 for (let i = 0; i &lt; nums.length; i++) &#123; for (let j = 0; j &lt; nums.length - i - 1; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; &#125; &#125; &#125; for (let i = 0; i &lt; nums.length; i += 2) &#123; if (nums[i] != nums[i + 1]) &#123; return nums[i]; &#125; &#125; return nums[nums.length - 1];&#125;; 运行时长： 解法三 异或运算先来看下异或运算的描述 任何数与0异或都不会改变他的数值 x ^ 0 = x 任何数与自身异都为0 x^x = 0 正好利用以上两点完美的解决。 12345678var singleNumber = function(nums) &#123; let num = 0; for (let i = 0; i &lt; nums.length; i++) &#123; num = num ^ nums[i]; &#125; console.log(num); return num;&#125;; 执行时长]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first]]></title>
    <url>%2F2019%2F09%2F18%2FHelloHexo%2F</url>
    <content type="text"><![CDATA[第一篇文章 Hello hexo发布流程新建1hexo new &quot;hello-world&quot; 创建tags1hexo new page tags 参考链接 https://www.jianshu.com/p/e17711e44e00Hexo使用攻略-添加分类及标签 执行命令1hexo g 发布到github12hexo cleanhexo g -d]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
