<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[关于前端-算法先说下自己不是科班出身 ，在工作的过程中深深的体会到算法的重要性，如果写的很差会导致程序运行很慢。。， 如何学习算法多看、多练、多思考。 多看 推荐《算法图解》《啊哈！算法》 新手 多练 leetCoce 、 牛客 https://leetcode-cn.com 多思考 养成总结的习惯，懂得变通。养成良好的思维方式 关于更新因为没太多时间更新在加上自己也处于学习阶段， 更新会比较慢。 希望自己能写出健壮、快速、精简的代码。共勉]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[singleNumber]]></title>
    <url>%2F2019%2F09%2F22%2FsingleNumber%2F</url>
    <content type="text"><![CDATA[只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/single-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解法1 应该是最慢的方法。。。违背了题意刚看到这个题的时候我以为是用对象就出结果了，尴尬。然后仔细想了下这不是消消乐那种嘛，虽然不怎么玩，但是想起来简单做起来难， 我第一次的解法确实最繁琐的。解法是利用了很多外部空间是数组加对象 利用数组判断出每个数字的循环次数 再用对象找出最小的那个。。。123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums[0]; &#125; let map = &#123;&#125;; let n = 1; let res = &apos;&apos;; for (let i = 0; i &lt; nums.length; i++) &#123; n = 1; for (let j = 0; j &lt; nums.length; j++) &#123; if (nums[i] === nums[j]) &#123; map[nums[i]] = n++; &#125; &#125; &#125; console.log(map, &apos;map&apos;); let min = 1; for (let key in map) &#123; if (map[key] &lt; min) &#123; min = map[key]; &#125; console.log(min, &apos;min&apos;); if (map[key] === min) &#123; res = key; &#125; &#125; console.log(res); return res;&#125;;let t = [ 2, 1, 2 ];let t1 = [ 4, 1, 2, 1, 2 ];singleNumber(t); 然后运行时长看图： 解法2 新建对象 相同的就删除 12345678910111213141516var singleNumber1 = function(nums) &#123; var obj = &#123;&#125;; for (let i = 0; i &lt; nums.length; i++) &#123; obj[nums[i]] = !obj[nums[i]]; if (!obj[nums[i]]) &#123; delete obj[nums[i]]; &#125; &#125; console.log(obj); return Object.keys(obj)[0];&#125;;let t = [ 2, 1, 2 ];let t1 = [ 4, 1, 2, 1, 2 ];let t2 = [ 1, 3, 1, -1, 3 ];singleNumber1(t1); 运行图解-第一次用这个软件 运行时长 一些大神的解法 ：解法3 因为 除了某个元素只出现一次以外，其余每个元素均出现两次， 所以我们可以先排序，在以2为基数循环 第一步先排序 冒号排序972ms…, 自带的排序88ms 以2为基数每次循环 因为是排好序的又是相同的是两两出现当前的不等于后一个就是唯一的，如果没有找到不相等的就返回最后一个 12345678910111213141516171819202122var singleNumber2 = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums[0]; &#125; let tmp = 0; // 排序 for (let i = 0; i &lt; nums.length; i++) &#123; for (let j = 0; j &lt; nums.length - i - 1; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; &#125; &#125; &#125; for (let i = 0; i &lt; nums.length; i += 2) &#123; if (nums[i] != nums[i + 1]) &#123; return nums[i]; &#125; &#125; return nums[nums.length - 1];&#125;; 运行时长： 解法三 异或运算先来看下异或运算的描述 任何数与0异或都不会改变他的数值 x ^ 0 = x 任何数与自身异都为0 x^x = 0 正好利用以上两点完美的解决。 12345678var singleNumber = function(nums) &#123; let num = 0; for (let i = 0; i &lt; nums.length; i++) &#123; num = num ^ nums[i]; &#125; console.log(num); return num;&#125;; 执行时长]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first]]></title>
    <url>%2F2019%2F09%2F18%2FHelloHexo%2F</url>
    <content type="text"><![CDATA[第一篇文章 Hello hexo发布流程新建1hexo new &quot;hello-world&quot; 创建tags1hexo new page tags 参考链接 https://www.jianshu.com/p/e17711e44e00Hexo使用攻略-添加分类及标签 执行命令1hexo g 发布到github12hexo cleanhexo g -d]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
