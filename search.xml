<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[axios-cancelToken 总结]]></title>
    <url>%2F2019%2F10%2F08%2Faxios-cancelToken-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在vue 项目中我们通常会使用axios 来请求接口。在项目中遇到列表切换，防止快速多次点击列表导致请求频繁发送等等减轻服务器压力cancelToken取消请求就是一方案。 在ajax时代是用的abort()来取消接口请求的。 当然也有其他方法比如：节流、按钮置灰等等 基本用法看下官网的基本用法[cancelToken 取消请求] (http://www.axios-js.com/zh-cn/docs/#%E5%8F%96%E6%B6%88) 官网方法一1234567891011121314151617181920212223242526272829var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token // 标记&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; // 主动取消的在这可以捕捉到 &#125; else &#123; // 处理错误 &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel(&apos;Operation canceled by the user.&apos;);// post 取消请求axios.post(&apos;/user/123/&apos;,&#123; name:x&#125;,&#123; cancelToken:source.token // 是在第三个地方添加 &#125;).then(res =&gt; &#123; // 成功&#125;).catch(err =&gt; &#123; if(axios.isCancel(err))&#123; // 主动取消 &#125;else &#123; //其他错误 &#125;&#125;) 官网方法 二 可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：1234567891011const ConcelToken = axios.CancelTokenlet cancelaxios.get(&apos;/user/12345&apos;, &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// cancel the requestcancel(); ##看下在项目中如何使用 防止重复请求在做项目时会遇到用户连点按钮的情况造成服务器压力或是未知异常等， 为了避免这种情况可以给用户一个友好的提示，多次请求只有最后一次有效 1234567891011121314151617181920212223sendRequest() &#123; let that = this; if(this.cancelList)&#123; this.cancelList.cancel(&apos;我取消啦&apos;) &#125; this.cancelList = axios.CancelToken.source(); axios.get(&apos;http://jsonplaceholder.typicode.com/comments&apos;, &#123; cancelToken:that.cancelList.token &#125;) .then(res =&gt; &#123; // 你的逻辑 this.list = res &#125;) .catch(thrown =&gt; &#123; if (axios.isCancel(thrown)) &#123; // 如果调用了cancel方法，那么这里的res就是cancel传入的信息 alert(&apos;请不要点击过于频繁&apos;) &#125; else &#123; // 处理错误 alert(&apos;接收400 401 等其他错误&apos;) console.log(&apos;处理错误&apos;, thrown.message); &#125; &#125;) &#125;, 我们可以把他封装起来 1234567891011121314151617181920212223242526const clearHttpPendingList = (config) =&gt; &#123; Vue.prototype.pending.forEach((item, index) =&gt; &#123; if (config.url === item.url) &#123; item.c(); Vue.prototype.pending.splice(index, 1); &#125; if (config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;) &amp;&amp; localStorage.getItem(&apos;comments&apos;)) &#123; // 不同页面相同的接口 Vue.prototype.pending.splice(index, 1); &#125; &#125;);&#125;;axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;); 连续点后它的网络请求 取消上一个页面的pedding请求优化性能， 跳转之前取消 正在请求的接口 1234567891011121314151617181920212223Vue.prototype.pending = []; // //声明一个数组用于存储每个ajax请求的取消函数和ajax标识 请求的缓存axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;);router.afterEach((to, from) =&gt; &#123; Vue.prototype.pending.forEach((item) =&gt; &#123; item.c(); &#125;); Vue.prototype.pending = [];&#125;); 这个接口处于pedding状态跳转到其他页面取消 相同的接口不再调用的应用-项目中有的接口在多个页面调用， 这个接口返回的数据不会轻易改变。 这个时候我们就会用到这个canceltoken和页面缓存。比如这个重复接口是A， 思路是 先调用A接口然后把接口内容存到本地， 这样在任何页面调用A接口的时候就直接取消掉了， 看下代码 12345678910111213141516171819202122232425262728293031323334353637axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;);axios.interceptors.response.use( (response) =&gt; &#123; if (response.config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;)) &#123; localStorage.setItem(&apos;comments&apos;, JSON.stringify(response.data)); &#125; // comments 要缓存的接口 clearHttpPendingList(response.config); //在一个ajax响应后再执行一下取消操作，把已经完成的请求从pending中移除 // 响应成功的数据 return response; &#125;)const clearHttpPendingList = (config) =&gt; &#123; Vue.prototype.pending.forEach((item, index) =&gt; &#123; if (config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;) &amp;&amp; localStorage.getItem(&apos;comments&apos;)) &#123; // 不同页面相同的接口 item.c(); Vue.prototype.pending.splice(index, 1); &#125; &#125;);&#125;;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[关于前端-算法先说下自己不是科班出身 ，在工作的过程中深深的体会到算法的重要性，如果写的很差会导致程序运行很慢。。， 如何学习算法多看、多练、多思考。 多看 推荐《算法图解》《啊哈！算法》 新手 多练 leetCoce 、 牛客 https://leetcode-cn.com 多思考 养成总结的习惯，懂得变通。养成良好的思维方式 关于更新因为没太多时间更新在加上自己也处于学习阶段， 更新会比较慢。 希望自己能写出健壮、快速、精简的代码。共勉]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[singleNumber]]></title>
    <url>%2F2019%2F09%2F22%2FsingleNumber%2F</url>
    <content type="text"><![CDATA[只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/single-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解法1 应该是最慢的方法。。。违背了题意刚看到这个题的时候我以为是用对象就出结果了，尴尬。然后仔细想了下这不是消消乐那种嘛，虽然不怎么玩，但是想起来简单做起来难， 我第一次的解法确实最繁琐的。解法是利用了很多外部空间是数组加对象 利用数组判断出每个数字的循环次数 再用对象找出最小的那个。。。123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums[0]; &#125; let map = &#123;&#125;; let n = 1; let res = &apos;&apos;; for (let i = 0; i &lt; nums.length; i++) &#123; n = 1; for (let j = 0; j &lt; nums.length; j++) &#123; if (nums[i] === nums[j]) &#123; map[nums[i]] = n++; &#125; &#125; &#125; console.log(map, &apos;map&apos;); let min = 1; for (let key in map) &#123; if (map[key] &lt; min) &#123; min = map[key]; &#125; console.log(min, &apos;min&apos;); if (map[key] === min) &#123; res = key; &#125; &#125; console.log(res); return res;&#125;;let t = [ 2, 1, 2 ];let t1 = [ 4, 1, 2, 1, 2 ];singleNumber(t); 然后运行时长看图： 解法2 新建对象 相同的就删除 12345678910111213141516var singleNumber1 = function(nums) &#123; var obj = &#123;&#125;; for (let i = 0; i &lt; nums.length; i++) &#123; obj[nums[i]] = !obj[nums[i]]; if (!obj[nums[i]]) &#123; delete obj[nums[i]]; &#125; &#125; console.log(obj); return Object.keys(obj)[0];&#125;;let t = [ 2, 1, 2 ];let t1 = [ 4, 1, 2, 1, 2 ];let t2 = [ 1, 3, 1, -1, 3 ];singleNumber1(t1); 运行图解-第一次用这个软件 运行时长 一些大神的解法 ：解法3 因为 除了某个元素只出现一次以外，其余每个元素均出现两次， 所以我们可以先排序，在以2为基数循环 第一步先排序 冒号排序972ms…, 自带的排序88ms 以2为基数每次循环 因为是排好序的又是相同的是两两出现当前的不等于后一个就是唯一的，如果没有找到不相等的就返回最后一个 12345678910111213141516171819202122var singleNumber2 = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums[0]; &#125; let tmp = 0; // 排序 for (let i = 0; i &lt; nums.length; i++) &#123; for (let j = 0; j &lt; nums.length - i - 1; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; &#125; &#125; &#125; for (let i = 0; i &lt; nums.length; i += 2) &#123; if (nums[i] != nums[i + 1]) &#123; return nums[i]; &#125; &#125; return nums[nums.length - 1];&#125;; 运行时长： 解法三 异或运算先来看下异或运算的描述 任何数与0异或都不会改变他的数值 x ^ 0 = x 任何数与自身异都为0 x^x = 0 正好利用以上两点完美的解决。 12345678var singleNumber = function(nums) &#123; let num = 0; for (let i = 0; i &lt; nums.length; i++) &#123; num = num ^ nums[i]; &#125; console.log(num); return num;&#125;; 执行时长]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first]]></title>
    <url>%2F2019%2F09%2F18%2FHelloHexo%2F</url>
    <content type="text"><![CDATA[第一篇文章 Hello hexo发布流程新建1hexo new &quot;hello-world&quot; 创建tags1hexo new page tags 参考链接 https://www.jianshu.com/p/e17711e44e00Hexo使用攻略-添加分类及标签 执行命令1hexo g 发布到github12hexo cleanhexo g -d]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
