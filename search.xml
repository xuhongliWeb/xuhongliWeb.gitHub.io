<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2020%2F12%2F20%2FPromise%2F</url>
    <content type="text"><![CDATA[Promise 是什么？Promise 是异步编程的一种解决方案，比传统的方案一一回调更合理更强大。 所谓Promise ,简单来说。里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果从语法上说 。 Promise 是一个对象， 从它可以获取异步操作的消息。Promise提供的API，各种异步操作都可以用通用的方法处理 。 Promise 对象有两个特点 对象的状态不受外界影响Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 一旦状态改变。就不会在变 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 中的事件循环 Event Loop]]></title>
    <url>%2F2020%2F07%2F09%2Fjavascript-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop%2F</url>
    <content type="text"><![CDATA[javascript 为什么是单线程?单线程也就是同一时间只能做一件事, 这也是js 语言的特点,那么为什么不弄个多线程呢? js的单线程与它的用于有关,作为浏览器语言, js,做的是与用户互动,操作DOM,如果是多线程了, 同一时间对一个DOM进行了增加和删除操作,这时候以哪一个为准? 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质 可以看下阮一峰老师的博客 同步与异步同步看下面代码这段代码的实现就叫做同步,也就是说按照顺序去做,做完第一件事情之后,再去做第二件事情 12345console.log(1)for(let i = 0; i&lt; 3; i++)&#123; console.log(i)&#125;console.log(4) 异步 (细分为宏任务和微任务)因为js是单线程的, 当任务多的时候就需要排队, 如果前面一个任务耗时很长, 后面一个任务就要一直等待.所以异步就出现了 宏任务有以下几种：①I/O②setTimeout③setInterval④setImmediate⑤requestAnimationFrame微任务有以下几种：①process.nextTick②MutationObserver③Promise.then catch finally 1234567891011121314console.log(&apos;start&apos;) // 同步setTimeout(() =&gt; &#123; console.log(&apos;宏任务&apos;)&#125;,0)new Promise((reslove) =&gt; &#123; console.log(&apos;p1&apos;) // prpmise 创建 就会立即执行 reslove()&#125;).then(res =&gt; &#123; console.log(&apos;p2&apos;) // &#125;)同步 &gt; 微任务 &gt; 宏任务 1234567891011121314151617console.log(&apos;start&apos;) // 同步setTimeout(() =&gt; &#123; console.log(&apos;宏任务&apos;)&#125;,2220)for (let index = 0; index &lt; 22000; index++) &#123;console.log(&apos;index&apos;) // setTimeout 的延时时间,取决与同步函数的运行时间, 这里登 延时函数运行的时候会立即输出&#125;new Promise((reslove) =&gt; &#123; console.log(&apos;p1&apos;) // prpmise 创建 就会立即执行 reslove()&#125;).then(res =&gt; &#123; console.log(&apos;then&apos;) // &#125;) 这个和上面的差不多, 只要理解了一个就面的也就理解了, 1234567891011121314151617181920212223console.log(&apos;start&apos;) // 同步setTimeout(() =&gt; &#123; console.log(&apos;宏任务&apos;) new Promise((reslove) =&gt; &#123; console.log(&apos;setTimeout p1&apos;) // prpmise 创建 就会立即执行 reslove() &#125;).then(res =&gt; &#123; console.log(&apos; setTimeout then&apos;) // &#125;)&#125;, 2220)for (let index = 0; index &lt; 22000; index++) &#123; console.log(&apos;index&apos;)&#125;new Promise((reslove) =&gt; &#123; console.log(&apos;p1&apos;) // prpmise 创建 就会立即执行 reslove()&#125;).then(res =&gt; &#123; console.log(&apos;then&apos;) // &#125;) 记住JS是单线程的, 任务也是一个一个取的 123456789let i = 0setTimeout(() =&gt; &#123; // 扔到任务队列 =&gt; 依次执行 i = 1 console.log(i++)&#125;,1000)setTimeout(() =&gt; &#123; // 扔到任务队列 =&gt; 依次执行 i = 2 console.log(i++)&#125;,1000) 任务队列(消息队列)任务队列是一个事件的队列(也可以理解成消息的队列)工作线程完成一项任务，就在”任务队列”中添加一个事件(也可以理解为发送一条消息)，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 所有同步任务都在主线程上执行，形成一个执行栈 主线程发起异步请求,相应的工作线程就会去执行异步任务 主线程可以继续执行后面的代码 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队 主线程把当前的事件执行完成之后,再去读取任务队列,如此反复重复 总结主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环） 代码从上到下执行, 优先执行同步函数, 在遇到异步函数时将该任务推入执行栈,当任务队列中没有同步任务,便开始从执行栈中取异步函数, 顺序是 微任务 &gt; 宏任务]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2020%2F07%2F04%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包是什么？ 闭包是指有权访问另一个函数作用域的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。 说起闭包就不得不聊聊作用域 闭包与变量对象和作用域链有着比较多的联系全局环境只能访问全局中定义的变量和方法, 不能直接访问局部环境中的方法和变量123456var title = &apos;blog&apos;function test() &#123; console.log(&apos;title&apos;) var u = &apos;uuu&apos;&#125;test() // 每调用一次都会在内存中开辟一个环境, 结束之后就销毁(变量不在被引用) 每调用一次都会在内存中开辟一个环境, 结束之后就销毁(变量不在被引用就会被回收)延长作用域链来实现让X的值每次调用都加11234567891011由于每次调用都会在内存中开辟新的地址, 最重要的是里面的变量没被引用, 所以在结束之后就会被销毁. 不能实现累加效果function add () &#123; var x = 0 function sum() &#123; console.log(++x) &#125; sum()&#125;add()add() // 这样改造下 12345678910由add 返回的匿名函数一直在使用变量X,(利用闭包特性) 这样也就不会被销毁了, 在特定时候把add 设为 null 手动回收把 function add () &#123; var x = 0 return function () &#123; console.log(++x) &#125;&#125;var a = add()a()a() 什么是块级作用域?在ES6之前是没有块级作用域的, 不像 let const 这样 {} 外部不可以访问到里面的函数和变量 123456&#123; let b = 2 const c = 3&#125;console.log(b) // 不可以console.log(c) 不可以 在之前 这些变量添加到当前执行环境 在这里是全局环境 也就是window 在for 循环中尤为重要 1234567891011121314151617181920212223242526if(true) &#123; var b = 2 var c = 3&#125;console.log(b)console.log(c)for(var i = 0; i &lt; 3; i++)&#123; // 沿着作用域向上找 由于没有块级作用域 , 直接找到window 上的i setTimeout( function()&#123; console.log(i)gvnd &#125; ,1000)&#125;console.log(i,&apos;win&apos;)// 在定时器了输出d对应的jfor(var j = 0 ;j &lt; 3 ; j++) &#123; // 没有 变量作用域, 有函数作用域 利用每创建一个函数就会创建一个内存空间 (function(n)&#123; console.log(n) &#125;)(j)&#125; 应用12345678910111213// 应用let arr = [1,43,543,543,534,24,2,623,42,2132,35342,21,53,21,3,53,3,54,66]function f(a,b) &#123; return function (v) &#123; return v &gt; a &amp;&amp; v&lt; b &#125;&#125;console.log(arr.filter(f(0,100))) console.log(arr.filter(f(100,600))) 关于this在闭包中使用this对象可能会有一些问题, this 是在运行时基于环境绑定的. 在全局环境中 this 等于 window, 而当函数被当作某个对象的方法被调用时, this 等于那个对象, 不过匿名函数执行环境具有全局性, 因此this 对象通常指向window, 12345678// var obj = &#123;// name : &apos;obj1&apos;,// getName () &#123;// return this.name// &#125;// &#125;// console.log(obj.getName()) //正常 12345678910var obj = &#123; name : &apos;obj1&apos;, getName:function () &#123; return function ()&#123; return this.name &#125; &#125;&#125;console.log(obj.getName()()) // window 匿名函数执行环境具有全局性 怎么解决呢 1 利用作用域链, 在函数里面定义 正确的 this 变量,2 箭头函数 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 3 bind call apply // console.log(obj.getName().bind(obj)())// console.log(obj.getName().apply(obj))// console.log(obj.getName().call(obj)) 造成内存泄漏12345678910111213141516171819// 内存泄漏 function dom () &#123; var ele = document.querySelectorAll(&apos;.test&apos;) ele.onclick = function () &#123; console.log(ele.id) // 循环引用 &#125;&#125;// 优化 function dom () &#123; var ele = document.querySelectorAll(&apos;.test&apos;) var id = ele.id ele.onclick = function () &#123; console.log(id) // 循环引用 &#125; ele = null&#125; 总结闭包的常见的使用形式 返回一个函数 作为函数参数传递 回调函数 非典型闭包IIFE(立即执行函数表达式) 闭包结合了局部变量和全局变量的优点。可以使变量不污染全局，但是又能对变量进行重用。但是，其实闭包也有有缺点的，它比起普通函数会占用更多的内存。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echart-bar]]></title>
    <url>%2F2020%2F06%2F19%2Fechart-bar%2F</url>
    <content type="text"><![CDATA[echart 柱状图带背景且柱状条顶端显示文字的效果 实现方式第一种隐藏X轴，左侧文字用Y轴右侧用label标签 由于柱状图的背景颜色新增的数据， 所以在显示和hover的时候都要处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647yAxis: &#123; // 左侧柱状图的Y轴 splitLine: &apos;none&apos;, axisTick: &apos;none&apos;, axisLine: &apos;none&apos;, axisLabel: &#123; verticalAlign: &apos;top&apos;, align: &apos;center&apos;, padding: [-5, 50, 10, 15], textStyle: &#123; color: &apos;#333&apos;, fontSize: &apos;14&apos; &#125; &#125;, data: [&apos;站三&apos;, &apos;里斯&apos;, &apos;王二&apos;] // inverse: true &#125;, // 背景数据 // 背景 &#123; barGap: &apos;-100%&apos;, // Make series be overlap name: &apos;&apos;, type: &apos;bar&apos;, barWidth: 15, silent: true, // 关键 itemStyle: &#123; color: &apos;#F6F5FA&apos;, barBorderRadius: 6 &#125;, label: &#123; // 右侧文字 show: true, // 通过formatter函数来返回想要的数据 formatter: function (params) &#123; // 关键 for (let i = 0; i &lt; data.length; i++) &#123; if (params.dataIndex === i) &#123; return data[i] + &apos;人&apos; &#125; &#125; &#125;, position: &apos;right&apos;, textStyle: &#123; color: &apos;#333&apos; &#125; &#125;, data: [654, 654, 654] &#125;, ]]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2F2019%2F10%2F16%2F%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖和节流在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，用户体验非常差 此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 那么什么时候用防抖什么时候用节流呢 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。 一般页面频繁滚动时用节流， 页面里有个频繁触发的搜索框用防抖 节流 两种方式时间戳版 12345678910111213throttle(fn, delay = 500) &#123; let previous = 0; return function() &#123; let now = Date.now(); let context = this; let args = arguments; if (now - previous &gt; delay) &#123; fn.apply(context, args); // previous = now; &#125; &#125;;&#125; 运行结果： 定时器版 1234567891011121314151617/** * 调用这个方法一秒后才会执行， 之后没每隔delay秒运行一次函数 * 当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。 */ throttle_timer(fn, delay) &#123; let timer; return function() &#123; let that = this; let arg = arguments; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; timer = null; fn.apply(that, arg); &#125;, delay); &#125; &#125;; &#125;, 运行结果： 其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。 防抖当持续触发事件，一定时间内没有再触发事件，事件会重新执行一次 1234567891011debounce(fn, delay) &#123; let timer; return function() &#123; let that = this, arg = arguments; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(that, arg); &#125;, delay); &#125;; &#125;, 运行结果： 以上调用方法： 12345678910111213initSearch() &#123; const searchDom = this.$refs.inp; const that = this; // searchDom.addEventListener( // &quot;input&quot;, // that.throttle_timer(that.search, 1000) // ); searchDom.addEventListener( &quot;input&quot;, that.debounce(that.search, 500) ); // searchDom.addEventListener(&quot;input&quot;,that.throttle(that.search,5000))&#125;, 可以看出来， 持续触发事件，会被清楚， 只有最后一次事件触发过后，等待指定延时时间后在执行的.]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios-cancelToken 总结]]></title>
    <url>%2F2019%2F10%2F08%2Faxios-cancelToken-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在vue 项目中我们通常会使用axios 来请求接口。在项目中遇到列表切换，防止快速多次点击列表导致请求频繁发送等等减轻服务器压力cancelToken取消请求就是一方案。 在ajax时代是用的abort()来取消接口请求的。 当然也有其他方法比如：节流、按钮置灰等等 基本用法看下官网的基本用法[cancelToken 取消请求] (http://www.axios-js.com/zh-cn/docs/#%E5%8F%96%E6%B6%88) 官网方法一1234567891011121314151617181920212223242526272829var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token // 标记&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; // 主动取消的在这可以捕捉到 &#125; else &#123; // 处理错误 &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel(&apos;Operation canceled by the user.&apos;);// post 取消请求axios.post(&apos;/user/123/&apos;,&#123; name:x&#125;,&#123; cancelToken:source.token // 是在第三个地方添加 &#125;).then(res =&gt; &#123; // 成功&#125;).catch(err =&gt; &#123; if(axios.isCancel(err))&#123; // 主动取消 &#125;else &#123; //其他错误 &#125;&#125;) 官网方法 二 可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：1234567891011const ConcelToken = axios.CancelTokenlet cancelaxios.get(&apos;/user/12345&apos;, &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// cancel the requestcancel(); ##看下在项目中如何使用 防止重复请求在做项目时会遇到用户连点按钮的情况造成服务器压力或是未知异常等， 为了避免这种情况可以给用户一个友好的提示，多次请求只有最后一次有效 1234567891011121314151617181920212223sendRequest() &#123; let that = this; if(this.cancelList)&#123; this.cancelList.cancel(&apos;我取消啦&apos;) &#125; this.cancelList = axios.CancelToken.source(); axios.get(&apos;http://jsonplaceholder.typicode.com/comments&apos;, &#123; cancelToken:that.cancelList.token &#125;) .then(res =&gt; &#123; // 你的逻辑 this.list = res &#125;) .catch(thrown =&gt; &#123; if (axios.isCancel(thrown)) &#123; // 如果调用了cancel方法，那么这里的res就是cancel传入的信息 alert(&apos;请不要点击过于频繁&apos;) &#125; else &#123; // 处理错误 alert(&apos;接收400 401 等其他错误&apos;) console.log(&apos;处理错误&apos;, thrown.message); &#125; &#125;) &#125;, 我们可以把他封装起来 1234567891011121314151617181920212223242526const clearHttpPendingList = (config) =&gt; &#123; Vue.prototype.pending.forEach((item, index) =&gt; &#123; if (config.url === item.url) &#123; item.c(); Vue.prototype.pending.splice(index, 1); &#125; if (config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;) &amp;&amp; localStorage.getItem(&apos;comments&apos;)) &#123; // 不同页面相同的接口 Vue.prototype.pending.splice(index, 1); &#125; &#125;);&#125;;axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;); 连续点后它的网络请求 取消上一个页面的pedding请求优化性能， 跳转之前取消 正在请求的接口 1234567891011121314151617181920212223Vue.prototype.pending = []; // //声明一个数组用于存储每个ajax请求的取消函数和ajax标识 请求的缓存axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;);router.afterEach((to, from) =&gt; &#123; Vue.prototype.pending.forEach((item) =&gt; &#123; item.c(); &#125;); Vue.prototype.pending = [];&#125;); 这个接口处于pedding状态跳转到其他页面取消 相同的接口不再调用的应用-项目中有的接口在多个页面调用， 这个接口返回的数据不会轻易改变。 这个时候我们就会用到这个canceltoken和页面缓存。比如这个重复接口是A， 思路是 先调用A接口然后把接口内容存到本地， 这样在任何页面调用A接口的时候就直接取消掉了， 看下代码 12345678910111213141516171819202122232425262728293031323334353637axios.interceptors.request.use( (config) =&gt; &#123; clearHttpPendingList(config); config.cancelToken = new cancelToken(function executor(c) &#123; Vue.prototype.pending.push(&#123; url: config.url, c: c &#125;); &#125;); // 发送请求之前做的 return config; &#125;, (err) =&gt; &#123; // 请求错误 return Promise.reject(err); &#125;);axios.interceptors.response.use( (response) =&gt; &#123; if (response.config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;)) &#123; localStorage.setItem(&apos;comments&apos;, JSON.stringify(response.data)); &#125; // comments 要缓存的接口 clearHttpPendingList(response.config); //在一个ajax响应后再执行一下取消操作，把已经完成的请求从pending中移除 // 响应成功的数据 return response; &#125;)const clearHttpPendingList = (config) =&gt; &#123; Vue.prototype.pending.forEach((item, index) =&gt; &#123; if (config.url.includes(&apos;http://jsonplaceholder.typicode.com/comments&apos;) &amp;&amp; localStorage.getItem(&apos;comments&apos;)) &#123; // 不同页面相同的接口 item.c(); Vue.prototype.pending.splice(index, 1); &#125; &#125;);&#125;;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[关于前端-算法先说下自己不是科班出身 ，在工作的过程中深深的体会到算法的重要性，如果写的很差会导致程序运行很慢。。， 如何学习算法多看、多练、多思考。 多看 推荐《算法图解》《啊哈！算法》 新手 多练 leetCoce 、 牛客 https://leetcode-cn.com 多思考 养成总结的习惯，懂得变通。养成良好的思维方式 关于更新因为没太多时间更新在加上自己也处于学习阶段， 更新会比较慢。 希望自己能写出健壮、快速、精简的代码。共勉]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[singleNumber]]></title>
    <url>%2F2019%2F09%2F22%2FsingleNumber%2F</url>
    <content type="text"><![CDATA[只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/single-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解法1 应该是最慢的方法。。。违背了题意刚看到这个题的时候我以为是用对象就出结果了，尴尬。然后仔细想了下这不是消消乐那种嘛，虽然不怎么玩，但是想起来简单做起来难， 我第一次的解法确实最繁琐的。解法是利用了很多外部空间是数组加对象 利用数组判断出每个数字的循环次数 再用对象找出最小的那个。。。123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums[0]; &#125; let map = &#123;&#125;; let n = 1; let res = &apos;&apos;; for (let i = 0; i &lt; nums.length; i++) &#123; n = 1; for (let j = 0; j &lt; nums.length; j++) &#123; if (nums[i] === nums[j]) &#123; map[nums[i]] = n++; &#125; &#125; &#125; console.log(map, &apos;map&apos;); let min = 1; for (let key in map) &#123; if (map[key] &lt; min) &#123; min = map[key]; &#125; console.log(min, &apos;min&apos;); if (map[key] === min) &#123; res = key; &#125; &#125; console.log(res); return res;&#125;;let t = [ 2, 1, 2 ];let t1 = [ 4, 1, 2, 1, 2 ];singleNumber(t); 然后运行时长看图： 解法2 新建对象 相同的就删除 12345678910111213141516var singleNumber1 = function(nums) &#123; var obj = &#123;&#125;; for (let i = 0; i &lt; nums.length; i++) &#123; obj[nums[i]] = !obj[nums[i]]; if (!obj[nums[i]]) &#123; delete obj[nums[i]]; &#125; &#125; console.log(obj); return Object.keys(obj)[0];&#125;;let t = [ 2, 1, 2 ];let t1 = [ 4, 1, 2, 1, 2 ];let t2 = [ 1, 3, 1, -1, 3 ];singleNumber1(t1); 运行图解-第一次用这个软件 运行时长 一些大神的解法 ：解法3 因为 除了某个元素只出现一次以外，其余每个元素均出现两次， 所以我们可以先排序，在以2为基数循环 第一步先排序 冒号排序972ms…, 自带的排序88ms 以2为基数每次循环 因为是排好序的又是相同的是两两出现当前的不等于后一个就是唯一的，如果没有找到不相等的就返回最后一个 12345678910111213141516171819202122var singleNumber2 = function(nums) &#123; if (nums.length &lt; 2) &#123; return nums[0]; &#125; let tmp = 0; // 排序 for (let i = 0; i &lt; nums.length; i++) &#123; for (let j = 0; j &lt; nums.length - i - 1; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; &#125; &#125; &#125; for (let i = 0; i &lt; nums.length; i += 2) &#123; if (nums[i] != nums[i + 1]) &#123; return nums[i]; &#125; &#125; return nums[nums.length - 1];&#125;; 运行时长： 解法三 异或运算先来看下异或运算的描述 任何数与0异或都不会改变他的数值 x ^ 0 = x 任何数与自身异都为0 x^x = 0 正好利用以上两点完美的解决。 12345678var singleNumber = function(nums) &#123; let num = 0; for (let i = 0; i &lt; nums.length; i++) &#123; num = num ^ nums[i]; &#125; console.log(num); return num;&#125;; 执行时长]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first]]></title>
    <url>%2F2019%2F09%2F18%2FHelloHexo%2F</url>
    <content type="text"><![CDATA[第一篇文章 Hello hexo发布流程新建1hexo new &quot;hello-world&quot; 创建tags1hexo new page tags 参考链接 https://www.jianshu.com/p/e17711e44e00Hexo使用攻略-添加分类及标签 执行命令1hexo g 发布到github12hexo cleanhexo g -d]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
