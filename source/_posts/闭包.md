---
title: 闭包
date: 2020-07-04 08:08:08
tags: js
---

## 闭包是什么？
  闭包是指有权访问另一个函数作用域的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

## 说起闭包就不得不聊聊作用域 闭包与变量对象和作用域链有着比较多的联系

### 全局环境只能访问全局中定义的变量和方法, 不能直接访问局部环境中的方法和变量

```+*******
var title = 'blog'
function test() {
  console.log('title')
  var u = 'uuu'
}
test() // 每调用一次都会在内存中开辟一个环境, 结束之后就销毁(变量不在被引用)


```

### 每调用一次都会在内存中开辟一个环境, 结束之后就销毁(变量不在被引用就会被回收)


### 延长作用域链

    来实现让X的值每次调用都加1

```
由于每次调用都会在内存中开辟新的地址, 最重要的是里面的变量没被引用, 所以在结束之后就会被销毁. 不能实现累加效果
function add () {
  var x = 0
  function sum() {
    console.log(++x)
  }
  sum()
}

add()
add() // 
```

这样改造下 

```
由add 返回的匿名函数一直在使用变量X,(利用闭包特性) 这样也就不会被销毁了, 在特定时候把add 设为 null 手动回收把 
function add () {
  var x = 0
  return function () {
    console.log(++x)
  }
}
var a = add()
a()
a()
```

### 什么是块级作用域?

在ES6之前是没有块级作用域的, 不像 let const 这样 {} 外部不可以访问到里面的函数和变量
```
{
  let b = 2
  const c = 3
}
console.log(b) // 不可以
console.log(c) 不可以
```

在之前 这些变量添加到当前执行环境 在这里是全局环境 也就是window  在for 循环中尤为重要

```
if(true) {
  var b = 2
  var c = 3
}
console.log(b)
console.log(c)


for(var i = 0; i < 3; i++){
  // 沿着作用域向上找 由于没有块级作用域 , 直接找到window 上的i

  setTimeout(
      function(){
        console.log(i)gvnd
      }
    ,1000)
}
console.log(i,'win')

// 在定时器了输出d对应的j
for(var j = 0 ;j < 3 ; j++) {
  // 没有 变量作用域, 有函数作用域 利用每创建一个函数就会创建一个内存空间
  (function(n){
    console.log(n)
  })(j)
}


```

### 应用

```
// 应用

let arr = [1,43,543,543,534,24,2,623,42,2132,35342,21,53,21,3,53,3,54,66]


function f(a,b) {
  return function (v) {
    return v > a && v< b
  }
}

console.log(arr.filter(f(0,100))) 
console.log(arr.filter(f(100,600)))

```

### 关于this 

在闭包中使用this对象可能会有一些问题, this 是在运行时基于环境绑定的. 在全局环境中 this 等于 window, 而当函数被当作某个对象的方法被调用时, this 等于那个对象, 不过匿名函数执行环境具有全局性, 因此this 对象通常指向window,


```
// var obj = {
//   name : 'obj1',
//   getName () {
//     return this.name
//   }
// }

// console.log(obj.getName()) //正常

```


```

var obj = {
  name : 'obj1',
   getName:function () {
    return function (){
      return this.name
    }
  }
}
console.log(obj.getName()()) // window 匿名函数执行环境具有全局性

```

怎么解决呢 

1 利用作用域链, 在函数里面定义 正确的 this 变量, 
2 箭头函数 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

3 bind call apply 

// console.log(obj.getName().bind(obj)())
// console.log(obj.getName().apply(obj))
// console.log(obj.getName().call(obj))


### 造成内存泄漏


```
// 内存泄漏 

function dom () {
  var ele = document.querySelectorAll('.test')
  ele.onclick = function () {
    console.log(ele.id) // 循环引用
  }
}

// 优化 

function dom () {
  var ele = document.querySelectorAll('.test')
  var id = ele.id
  ele.onclick = function () {
    console.log(id) // 循环引用
  }
  ele = null
}

```

## 总结 

闭包的常见的使用形式
- 返回一个函数
- 作为函数参数传递
- 回调函数
- 非典型闭包IIFE(立即执行函数表达式)

闭包结合了局部变量和全局变量的优点。可以使变量不污染全局，但是又能对变量进行重用。但是，其实闭包也有有缺点的，它比起普通函数会占用更多的内存。