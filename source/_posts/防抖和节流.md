---
title: 防抖和节流
date: 2019-10-16 17:13:45
categories: 
- web前端
tags: js
---
### 防抖和节流

在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，用户体验非常差

此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。

那么什么时候用防抖什么时候用节流呢
借用github上一位大佬说的 
就像一窝蜂的人去排队看演出，队伍很乱，看门的老大爷每隔1秒，让进一个人，这个叫throttle，如果来了这一窝蜂的人，老大爷一次演出只让进一个人，下次演出才让下一个人进，这个就叫debounce（如果用onresize类比，就是鼠标mousedown，然后疯狂缩放窗口，然后鼠标mouseup，这整个过程就是一次演出，这次演出只允许一个人看即只执行一次回调）。

函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。

* 按一个按钮发送 AJAX：给 click 加了 debounce 后就算用户不停地点这个按钮，也只会最终发送一次；如果是 throttle 就会间隔发送几次

* 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次
#### 节流

函数节流的原理挺简单的，一种方式是定时器。当我触发一个时间时，先setTimeOut让这个时间延迟一会执行，如果在这个时间间隔内又触发了事件。那我们就清除了原来的定时器。在setTimeout一个新的定时器延迟一会执行 
函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。

##### throttle 应用场景

* DOM 元素的拖拽功能实现（mousemove）
* 计算鼠标移动的距离（mousemove）
* 搜索联想（keyup）
* 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次

```
/**
 * @author
 * @description 节流第一次会触发 最后一次不会触发
 */

export const _throttle = function(func, wait) {
  var prev = 0
  return function() {
    var context = this
    var args = arguments
    var now = +new Date()
    if (now - prev > wait) {
      // 第一次肯定执行  把上一次 的 now 复制给 prev 
      // 第二次 生成新的时间戳 减去 上一次的 如果大于等于间隔事件就执行。反之不执行
      // 重复 以上操作

      func.apply(context, args)
      prev = now
    }
  }
}


```
/**
 * 
 * @param {*} wait 
 * @param {*} func
 * @description 第一次不会触发 最后一次会触发 
 prev = 0
now = 10 
wait 2 
第一次 prev 10 
第二次 num 13 - 10 》 wait 成立 
       prev = 13 
      ... 循环下去
 */

 export const _throttle2 = function (func,wait) {
   let context,timer,args;
   return function () {
     context = this
     args = arguments
     if(!timer) { // 在这里区别
      timer = setTimeout(() => {
        timer = null
        func.apply(context,args)
      }, wait);
     }
   }
 }
运行结果：
![throttle.gif](http://ww1.sinaimg.cn/large/006xVFBigy1gafva1171lg30zw0f2jsn.gif)

我们既想首次调用，也要最后触发。 把两者结合下


```
 /**
  * @description 两者结合
  * 长按由于更新了时间不满足时间戳走了定时器？
  prev = 0
  now = 10 
  wait 2 
  第一次 prev 10 
  2 秒钟 后是 12
  在2秒内的连点不会触发执行
  连点由于第一个条件不成立，一直走定时器的
  ... 循环下去
  * 
  */

export const throttle3 = function (func,wait) {
  let timer,context,prev = 0,now,args;
  return function () {
    context = this
    args = arguments
    now = +new Date()
    if(now - prev > wait) { 
    console.log(now - prev > wait, 'now - prev')
      // debugger
      console.log('时间戳')
      if(timer){ // 结束后重新计算时间
        clearTimeout(timer)
        timer = null
      }
      func.apply(context,args)
      prev = now
    }else if(!timer){
      console.log('定时器')
    console.log(now - prev > wait, 'now - prev')
      // debugger
      timer = setTimeout(() => {
        prev = +new Date() // 重置前一次触发的时间戳 
        func.apply(context, args)
        timer = null
      }, wait);
    }
  }
}
```
通过选项来控制 头部调用还是尾部调用

```
/**
 * 完整版 的 节流 
 * @param {object} option
 * 如果您想禁用前沿呼叫，请传递{leading：false}，并且如果您要禁用后沿执行，请传递
 {trailing: false}. 
 */

 export const _throttle4 = function (func,wait,option) {
   let context,timer,args,now,prev = 0;
   if(!option) {option = {}}
   return function () {
     context = this
     now = +new Date()
     args = arguments
     console.log(option, 'option')
     if(option.leading === false) {
      prev = now // 禁用首次执行
     }
     if(now - prev > wait) {
      if(timer) {
        clearTimeout(timer)
        timer = null
      }
      func.apply(context,args)
      prev = now
     }else if(!timer && option.trailing !== false) {
      timer = setTimeout(() => {
        timer = null
        func.apply(context, args)
        prev = +new Date()
      }, wait);
     }
   }
 }
```
运行结果：
![throttle_timer.gif](http://ww1.sinaimg.cn/large/006xVFBigy1gafvesmoikg30zw0f276c.gif)

input 中的节流的应用
```
 <div>
    <vx-input v-model="key" ref="inp" />
    <vx-button ref="btn">搜索</vx-button>
  </div>
import {_throttle3,_throttle,_throttle2,_throttle4} from 'lib/utils'
mounted(){
  const inp = this.$refs.inp.$el
  const btn = this.$refs.btn.$el
  console.log(inp)
  const that = this
  const op = {
    leading:false, // 禁用首次执行
    trailing:true
  }
  // 节流 
  inp.addEventListener('input',_throttle4(that.searchInp,2000,op)) 
  btn.addEventListener('click',_throttle(that.searchInp,1000)) 
},
```

其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。

#### 防抖
防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，
##### debounce 应用场景

* 每次 resize/scroll 触发统计事件
* 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）

当持续触发事件，一定时间内没有再触发事件，事件会重新执行一次
红宝书》给出了最简洁最经典的去抖代码（书中说是节流，实则为去抖），调用如下

```
function debounce(method, context) {
  clearTimeout(method.tId);
  method.tId = setTimeout(function() {
    method.call(context);
  }, 1000);
}

function print() {
  console.log('hello world');
}

window.onscroll = function() {
  debounce(print);
};

在窗口内滚动一次，停止，1000ms 后，打印了 hello world，因为我们设置了一个 1000ms 延迟的定时器，细思非常巧妙。连续触发事件， 在结束后只触发一次
```
```
  debounce(fn, delay) {
      let timer;
      return function() {
        let that = this,
          arg = arguments;
        timer && clearTimeout(timer);
        timer = setTimeout(function() {
          fn.apply(that, arg);
        }, delay);
      };
    },
```


/**
 * @author 
 * @description 
 */
export const _debounce1 = function (method,wait = 1000) {
  let timer = null
  let n = 0
  return function () {
    let that = this
    let arg = arguments
    clearTimeout(timer)
    timer = setTimeout(function() {
      method.apply(that,arg)
    },wait)
    console.log(n++)
  }
}
/**
 * @description 第2版 支持立即执行的选项
 * 对立即参数传递true 以使debounce触发前导函数而不是等待间隔的后沿。在防止意外双击“提交”按钮从而再次发射的情况下很有用。
 */

 export const _debounce2 = function (func,wait,immediate) {
   let context,args,timer;
   return function () {
     context = this
     args = arguments
     if (timer) clearTimeout(timer);
    // 如果immediate 为 true 先执行一次
    if(immediate) {
      var callNow = !timer
      timer = setTimeout(() => {
        timer = null  
      }, wait);
      if(callNow) {
        func.apply(context, args)
      }
    }else {
      timer = setTimeout(() => {
        func.apply(context,args)
      }, wait);
    }
   }
 }
以上调用方法：
```
  // 防抖 
  inp.addEventListener('input',debounce(that.searchInp,2000,true)) 
```
运行结果：
![debounce.gif](http://ww1.sinaimg.cn/large/006xVFBigy1gafvzom10rg30zw0f2di3.gif)

可以看出来， 持续触发事件，会被清楚， 只有最后一次事件触发过后，等待指定延时时间后在执行的.



 